#!/usr/bin/perl -w
package App::DrKnow;

use strict;
use warnings;
use File::Temp qw(tempdir);
use Log::Log4perl qw(:easy);
use File::Spec::Functions;
use File::Spec;
use File::Path;
use File::Copy;
use File::Find;
use File::Basename;
use Data::Printer;
use Data::Dumper;
use IPC::Run qw(run);
use Cwd;
use Getopt::Long;
use Term::ShellUI;
use AI::MicroStructure;
use AI::MicroStructure::Object;
use AI::MicroStructure::ObjectSet;

our $VERSION = "0.16";


use  Term::ProgressBar::Simple;
use  Term::ProgressBar;
use  Term::Emit  qw/:all/,  {-bullets  =>  ["  *  ",  "  +  ",  "  -  ",  "  "],
  -color  =>  1,
  -closestat  =>  "CATEGORY",
  -fh  =>  *STDERR,
  -width=>180};
use  Parallel::Runner;
use  common::sense;
use  JSON;
use  AI::MicroStructure::WordBlacklist;
use  Term::ShellUI;
use  Term::Complete;
use  Log::Log4perl  qw(:easy);
use  Log::Log4perl::Util;
our  $s=AI::MicroStructure::WordBlacklist::getStopWords('en');
our  @stop  =  keys  %$s;
our  $stop  =  join("|",@stop);
use  Time::HiRes  qw(  usleep  );
use  vars  qw(@ISA);
our  $found  =  {};
our  $files={};
our  @check  =  ();
our  $ms  =  AI::MicroStructure->new();
our  $state  =  AI::MicroStructure::Util::config();
our  $config  =  $state->{cfg};

our  $curSysDate  =  `date  +"%F"`;
     $curSysDate=~  s/\n//g;


use  Time::HiRes  qw(  usleep  );
use  vars  qw(@ISA);
our  $found  =  {};
our  $files={};
our  @check  =  ();
our $cache = {};
our  %opts  =  (categorys=>"biology",
                content=>"plant",
                verbose=>0,
                deep=>0,
                directory=>$ms->{state}->{cfg}->{"default"},
                cache_file=>  sprintf("%s/%s_.cache",
                $ms->{state}->{cfg}->{"default"},
                $curSysDate));

GetOptions  (\%opts,  "cache_file=s","categorys=s","content=s",  "directory=s",  "verbose=i",  "deep=i");

our  $TOP  =  "/media/Elements/media";
     $TOP  =  $opts{directory};

    my  $create  =  -1;
    my  $target_dir  =  $opts{directory};
    $target_dir  =  $TOP  unless(-d  $target_dir);
    my  $TOP_URL  =  "";

confirm(1);

our  $search  =  "";
  if(-d  $opts{directory}){
  $TOP  =  $opts{directory};
  }
  $opts{categorys}=~s/  /|/g;
  $search  =  $opts{categorys}  unless(!$opts{categorys});
our  $pdftk  =  'pdftk';
our  $pdftotext  =  'pdftotext';
my  @name  =();
my  @vals  =();
my  $set  =  {};
our  $type  =  {};
our  $action  =  {};
our  $sep=sprintf("%s%s%s","\n"x  3,"#"  x  70,"\n");

our $VERSION = "0.001";
our $DRY_RUN;
our $CONFIRM;
our $DRY_RUN_MSG;
our $DATA_SNIPPED_LEN = 60;
use constant DISCIPLIN => '0.001-brain.txt.gz';


our $descriptions = {action=>{},type=>{},location=>{}};
    $descriptions->{action} = {
                    'use'     =>"activate something !",
                    'new'     =>"creates something !",
                    'desc'    =>"show a description about something",
                    'delete'  =>"remove something",
                    'list'    =>"lists something",
                     'search'    =>"search something",
                     'change'  =>"modify something",
                     'plot'    =>"create vissualisation of something",
                     'cloudy'  =>"create optimal query surface for something",
};
    $descriptions->{type} = {
    'new'     =>"things you dont have yet",
    'my'      =>"things you have already",
    'related' =>"things which are related to you",
    'expanding' =>"expanding knowledge",
    #'fit'    =>"usefull things",
    };
    $descriptions->{location} = {
      'category'     =>"on your computer",
      'content'     =>"on a distant computer",
     };

our $cmd={"h" =>                { alias => "help", exclude_from_completion => 1 },
                "?" =>          { alias => "help", exclude_from_completion =>1 },
    "quit" =>           { alias => "exit", exclude_from_completion =>1 },
                "help" => {
                        desc =>sub{ print usage();},
                        args => sub { shift->help_args(undef, @_); },
                        method => sub { shift->help_call(undef, @_); }
                },
                "history" => { desc => "Prints the command history",
                        doc => "Specify a number to list the last N lines of history\n" .
                                "Pass -c to clear the command history, " .
                                "-d NUM to delete a single item\n",
                        args => "[-c] [-d] [number]",
                        exclude_from_completion =>1,
                        method => sub { shift->history_call(@_) },
                },
                "exit" => {
                        desc => "Exits the program.",
                        maxargs => 0,
                        exclude_from_completion =>1,
                        method => sub { shift->exit_requested(1); },
                },
                "quit" => {
                        desc => "Quit using Fileman",
                        maxargs => 0,
                        method => sub { shift->exit_requested(1); }, exclude_from_completion => 1,
                },
                # Term::ShellUI normally displays "asdf: unknown command".
                # This shows how to use the default command.  If the user
                # type an unknown command, ShellUI calls '' if it exists.
                '' => {
                        proc => "No command here by that name!\n",
                        desc => "No help for unknown commands.",
                        doc => "Well, here's a little help: don't type them.\n",
                },
        };
our $location = {
  "category" => {
        args => "(path)",
        desc => "use list new",
        proc => sub {
                                                my $self = shift;
                                                my $parms = shift;
                                                print get_cname(@_) .
                                                        ": " . join(" ",@_), "\n";
                                        },
                },
"content" => {
                        args => sub {   },
        desc => $descriptions->{location}->{content},
        proc => sub{  App::DrKnow::invoke(); }}
};

  our %name = (action=>[qw/list use new/],#search get set   change plot cloudy
                          type=>[qw/new my related/],# popular growing fit term
                          location=>[qw/category content/]);




###########################################
sub new {
###########################################
    my($class, %options) = @_;

    my $self = {
        tar                  => undef,
        tmpdir               => undef,
        tar_read_options     => '',
        tar_write_options    => '',
        tar_gnu_read_options => [],
        dirs                 => 0,
        max_cmd_line_args    => 512,
        ramdisk              => undef,
        %options,
    };

    bless $self, $class;

    $self->{tar} = bin_find("tar") unless defined $self->{tar};
    $self->{tar} = bin_find("gtar") unless defined $self->{tar};

    if( ! defined $self->{tar} ) {
        LOGDIE "tar not found in PATH, please specify location";
    }

    if(defined $self->{ramdisk}) {
        my $rc = $self->ramdisk_mount( %{ $self->{ramdisk} } );
        if(!$rc) {
            LOGDIE "Mounting ramdisk failed";
        }
        $self->{tmpdir} = $self->{ramdisk}->{tmpdir};
    } else {
        $self->{tmpdir} = tempdir($self->{tmpdir} ?
                                        (DIR => $self->{tmpdir}) : ());
    }

    $self->{tardir} = File::Spec->catfile($self->{tmpdir}, "tar");
    mkpath [$self->{tardir}], 0, 0755 or
        LOGDIE "Cannot mkpath $self->{tardir} ($!)";

    $self->{objdir} = tempdir();

    return $self;
}

sub bin_find {
    my($exe) = @_;
    my @paths = split /:/, $ENV{PATH};
    push @paths,
         "/usr/bin",
         "/bin",
         "/usr/sbin",
         "/opt/bin",
         "/ops/csw/bin",
         ;
    for my $path ( @paths ) {
        my $full = File::Spec->catfile($path, $exe);
            return $full if -x $full;
    }
    return undef;
}
sub confirm {
    my($on) = @_;
    $CONFIRM = $on;
}
sub _confirm {
    my($msg) = @_;
    if($DRY_RUN) {
        INFO "$msg $DRY_RUN_MSG";
        return 0 if $DRY_RUN;
    }
    if($CONFIRM) {
        my $answer = ask("$msg ([y]/n)", "y");
        if($answer =~ /^\s*y\s*$/) {
            INFO $msg;
            return 1;
        }
        INFO "$msg (*CANCELLED* as requested)";
        return 0;
    }
    return 1;
}
sub dry_run {
    my($on) = @_;
    if($on) {
        $DRY_RUN     = 1;
        $DRY_RUN_MSG = "(skipped - dry run)";
    } else {
        $DRY_RUN     = 0;
        $DRY_RUN_MSG = "";
    }
}
sub ask {
##################################################
    my ($prompt, $default) = @_;
    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;
    if(@_ != 2) {
        LOGCROAK("ask() called with wrong # of args");
    }
  print STDERR "$prompt [$default]> "
        or die "Couldn't write STDERR: ($!)";
    my $value = <STDIN>;
    chomp $value;
    $value = $default if $value eq "";
    return $value;
}
###############################################
sub mkd {
###############################################
    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;
    _confirm "mkd @_" or return 1;
    INFO "mkpath @_";
    mkpath @_ or
        LOGCROAK("Cannot mkdir @_ ($!)");
}


###########################################
sub tardir {
###########################################
    my($self) = @_;

    return $self->{tardir};
}

###########################################
sub read {
###########################################
    my($self, $tarfile, @files) = @_;

    my $cwd = getcwd();

    unless(File::Spec::Functions::file_name_is_absolute($tarfile)) {
        $tarfile = File::Spec::Functions::rel2abs($tarfile, $cwd);
    }

    chdir $self->{tardir} or
        LOGDIE "Cannot chdir to $self->{tardir}";

    my $compr_opt = "";
    $compr_opt = "z" if $self->is_compressed($tarfile);

    my $cmd = [$self->{tar}, "${compr_opt}x$self->{tar_read_options}",
               @{$self->{tar_gnu_read_options}},
               "-f", $tarfile, @files];

    DEBUG "Running @$cmd";

    my $rc = run($cmd, \my($in, $out, $err));

    if(!$rc) {
         ERROR "@$cmd failed: $err";
         chdir $cwd or LOGDIE "Cannot chdir to $cwd";
         return undef;
    }

    WARN $err if $err;

    chdir $cwd or LOGDIE "Cannot chdir to $cwd";

    return 1;
}

###########################################
sub is_compressed {
###########################################
    my($self, $tarfile) = @_;

    return 1 if $tarfile =~ /\.t?gz$/i;

        # Sloppy check for gzip files
    open FILE, "<$tarfile" or die "Cannot open $tarfile";
    binmode FILE;
    my $read = sysread(FILE, my $two, 2, 0) or die "Cannot sysread";
    close FILE;
    return 1 if
        ord(substr($two, 0, 1)) eq 0x1F and
        ord(substr($two, 1, 1)) eq 0x8B;

    return 0;
}

###########################################
sub locate {
###########################################
    my($self, $rel_path) = @_;

    my $real_path = File::Spec->catfile($self->{tardir}, $rel_path);

    if(-e $real_path) {
        DEBUG "$real_path exists";
        return $real_path;
    }
    DEBUG "$real_path doesn't exist";

    WARN "$rel_path not found in tarball";
    return undef;
}

###########################################
sub add {
###########################################
    my($self, $rel_path, $path_or_stringref, $opts) = @_;

    if($opts) {
        if(!ref($opts) or ref($opts) ne 'HASH') {
            LOGDIE "Option parameter given to add() not a hashref.";
        }
    }

    my $perm    = $opts->{perm} if defined $opts->{perm};
    my $uid     = $opts->{uid} if defined $opts->{uid};
    my $gid     = $opts->{gid} if defined $opts->{gid};
    my $binmode = $opts->{binmode} if defined $opts->{binmode};

    my $target = File::Spec->catfile($self->{tardir}, $rel_path);
    my $target_dir = dirname($target);

    if( ! -d $target_dir ) {
        if( ref($path_or_stringref) ) {
            $self->add( dirname( $rel_path ), dirname( $target_dir ) );
        } else {
            $self->add( dirname( $rel_path ), dirname( $path_or_stringref ) );
        }
    }

    if(ref($path_or_stringref)) {
        open FILE, ">$target" or LOGDIE "Can't open $target ($!)";
        if(defined $binmode) {
            binmode FILE, $binmode;
        }
        print FILE $$path_or_stringref;
        close FILE;
    } elsif( -d $path_or_stringref ) {
          # perms will be fixed further down
        mkpath($target, 0, 0755) unless -d $target;
    } else {
        copy $path_or_stringref, $target or
            LOGDIE "Can't copy $path_or_stringref to $target ($!)";
    }

    if(defined $uid) {
        chown $uid, -1, $target or
            LOGDIE "Can't chown $target uid to $uid ($!)";
    }

    if(defined $gid) {
        chown -1, $gid, $target or
            LOGDIE "Can't chown $target gid to $gid ($!)";
    }

    if(defined $perm) {
        chmod $perm, $target or
                LOGDIE "Can't chmod $target to $perm ($!)";
    }

    if(!defined $uid and
       !defined $gid and
       !defined $perm and
       !ref($path_or_stringref)) {
        perm_cp($path_or_stringref, $target) or
            LOGDIE "Can't perm_cp $path_or_stringref to $target ($!)";
    }

    1;
}

######################################
sub perm_cp {
######################################
    # Lifted from Ben Okopnik's
    # http://www.linuxgazette.com/issue87/misc/tips/cpmod.pl.txt

    my $perms = perm_get($_[0]);
    perm_set($_[1], $perms);
}

######################################
sub perm_get {
######################################
    my($filename) = @_;

    my @stats = (stat $filename)[2,4,5] or
        LOGDIE "Cannot stat $filename ($!)";

    return \@stats;
}

######################################
sub perm_set {
######################################
    my($filename, $perms) = @_;

    chown($perms->[1], $perms->[2], $filename) or
        LOGDIE "Cannot chown $filename ($!)";
    chmod($perms->[0] & 07777,    $filename) or
        LOGDIE "Cannot chmod $filename ($!)";
}

###########################################
sub remove {
###########################################
    my($self, $rel_path) = @_;

    my $target = File::Spec->catfile($self->{tardir}, $rel_path);

    rmtree($target) or LOGDIE "Can't rmtree $target ($!)";
}

###########################################
sub list_all {
###########################################
    my($self) = @_;

    my @entries = ();

    $self->list_reset();

    while(my $entry = $self->list_next()) {
        push @entries, $entry;
    }

    return \@entries;
}

###########################################
sub list_reset {
###########################################
    my($self) = @_;

    my $list_file = File::Spec->catfile($self->{objdir}, "list");
    open FILE, ">$list_file" or LOGDIE "Can't open $list_file";

    my $cwd = getcwd();
    chdir $self->{tardir} or LOGDIE "Can't chdir to $self->{tardir} ($!)";

    find(sub {
              my $entry = $File::Find::name;
              $entry =~ s#^\./##;
              my $type = (-d $_ ? "d" :
                          -l $_ ? "l" :
                                  "f"
                         );
              print FILE "$type $entry\n";
            }, ".");

    chdir $cwd or LOGDIE "Can't chdir to $cwd ($!)";

    close FILE;

    $self->offset(0);
}

###########################################
sub list_next {
###########################################
    my($self) = @_;

    my $offset = $self->offset();

    my $list_file = File::Spec->catfile($self->{objdir}, "list");
    open FILE, "<$list_file" or LOGDIE "Can't open $list_file";
    seek FILE, $offset, 0;

    { my $line = <FILE>;

      return undef unless defined $line;

      chomp $line;
      my($type, $entry) = split / /, $line, 2;
      redo if $type eq "d" and ! $self->{dirs};
      $self->offset(tell FILE);
      return [$entry, File::Spec->catfile($self->{tardir}, $entry),
              $type];
    }
}

###########################################
sub offset {
###########################################
    my($self, $new_offset) = @_;

    my $offset_file = File::Spec->catfile($self->{objdir}, "offset");

    if(defined $new_offset) {
        open FILE, ">$offset_file" or LOGDIE "Can't open $offset_file";
        print FILE "$new_offset\n";
        close FILE;
    }

    open FILE, "<$offset_file" or LOGDIE "Can't open $offset_file (Did you call list_next() without a previous list_reset()?)";
    my $offset = <FILE>;
    chomp $offset;
    return $offset;
    close FILE;
}

###########################################
sub write {
###########################################
    my($self, $tarfile, $compress) = @_;

    my $cwd = getcwd();
    chdir $self->{tardir} or LOGDIE "Can't chdir to $self->{tardir} ($!)";

    unless(File::Spec::Functions::file_name_is_absolute($tarfile)) {
        $tarfile = File::Spec::Functions::rel2abs($tarfile, $cwd);
    }

    my $compr_opt = "";
    $compr_opt = "z" if $compress;

    opendir DIR, "." or LOGDIE "Cannot open $self->{tardir}";
    my @top_entries = grep { $_ !~ /^\.\.?$/ } readdir DIR;
    closedir DIR;

    my $cmd;

    if(@top_entries > $self->{max_cmd_line_args}) {
        my $filelist_file = $self->{tmpdir}."/file-list";
        open FLIST, ">$filelist_file" or
            LOGDIE "Cannot open $filelist_file ($!)";
        for(@top_entries) {
            print FLIST "$_\n";
        }
        close FLIST;
        $cmd = [$self->{tar}, "${compr_opt}cf$self->{tar_write_options}",
                $tarfile, "-T", $filelist_file];
    } else {
        $cmd = [$self->{tar}, "${compr_opt}cf$self->{tar_write_options}",
                $tarfile, @top_entries];
    }


    DEBUG "Running @$cmd";
    my $rc = run($cmd, \my($in, $out, $err));

    if(!$rc) {
         ERROR "@$cmd failed: $err";
         chdir $cwd or LOGDIE "Cannot chdir to $cwd";
         return undef;
    }

    WARN $err if $err;

    chdir $cwd or LOGDIE "Cannot chdir to $cwd";

    return 1;
}

###########################################
sub DESTROY {
###########################################
    my($self) = @_;

    $self->ramdisk_unmount() if defined  $self->{ramdisk};

    rmtree($self->{objdir}) if defined $self->{objdir};
    rmtree($self->{tmpdir}) if defined $self->{tmpdir};
}

######################################
sub bin_find {
######################################
    my($exe) = @_;

    my @paths = split /:/, $ENV{PATH};

    push @paths,
         "/usr/bin",
         "/bin",
         "/usr/sbin",
         "/opt/bin",
         "/ops/csw/bin",
         ;

    for my $path ( @paths ) {
        my $full = File::Spec->catfile($path, $exe);
            return $full if -x $full;
    }

    return undef;
}

###########################################
sub is_gnu {
###########################################
    my($self) = @_;

    open PIPE, "$self->{tar} --version |" or
        return 0;

    my $output = join "\n", <PIPE>;
    close PIPE;

    return $output =~ /GNU/;
}

###########################################
sub ramdisk_mount {
###########################################
    my($self, %options) = @_;

      # mkdir -p /mnt/myramdisk
      # mount -t tmpfs -o size=20m tmpfs /mnt/myramdisk

     $self->{mount}  = bin_find("mount") unless $self->{mount};
     $self->{umount} = bin_find("umount") unless $self->{umount};

     for (qw(mount umount)) {
         if(!defined $self->{$_}) {
             LOGWARN "No $_ command found in PATH";
             return undef;
         }
     }

     $self->{ramdisk} = { %options };

     $self->{ramdisk}->{size} = "100m" unless
       defined $self->{ramdisk}->{size};

     if(! defined $self->{ramdisk}->{tmpdir}) {
         $self->{ramdisk}->{tmpdir} = tempdir( CLEANUP => 1 );
     }

     my @cmd = ($self->{mount},
                "-t", "tmpfs", "-o", "size=$self->{ramdisk}->{size}",
                "tmpfs", $self->{ramdisk}->{tmpdir});

     INFO "Mounting ramdisk: @cmd";
     my $rc = system( @cmd );

    if($rc) {
        LOGWARN "Mount command '@cmd' failed: $?";
        LOGWARN "Note that this only works on Linux and as root";
        return;
    }

    $self->{ramdisk}->{mounted} = 1;

    return 1;
}

###########################################
sub ramdisk_unmount {
###########################################
    my($self) = @_;

    return if !exists $self->{ramdisk}->{mounted};

    my @cmd = ($self->{umount}, $self->{ramdisk}->{tmpdir});

    INFO "Unmounting ramdisk: @cmd";

    my $rc = system( @cmd );

    if($rc) {
        LOGWARN "Unmount command '@cmd' failed: $?";
        return;
    }

    delete $self->{ramdisk};
    return 1;
}


sub getCommands
{
  my @c = keys $descriptions->{action};
  foreach my $ele (@c){
  my $s ={};
  $cmd->{$ele}->{cmds} = $s;
  foreach (keys %{$descriptions->{location}}){
    $s->{$_}->{cmds} = {};
  }
}
return $cmd;
}

sub usage {


  # create some things to loop over


printf("
             i!~!!))!!!!!!!!!!!!!!!!!!!!!!!!
          i!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
       i!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    '!h!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  '!!`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
   /!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
' ':)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ~:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
..!!!!!\!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 `!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ~ ~!!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!~
~~'~{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:'~
{-{)!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:!
`!!!!{!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!':!!!
' {!!!{>)`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)!~..
:!{!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -!!:
    ~:!4~/!!!!!!!!!!!!!!!!!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!
     :~!!~)(!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ``~!!).~!!!!!!!!!!!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:
            ~  '!\!!!!!!!!!!(!!!!!!!!!!!!!!!!!!!!!!4!!!~:
           '      '--`!!!!!!!!/:\!!{!!((!~.~!!`?~-      :
              ``-.    `~!{!`)(>~/ \~                   :
   .                \  : `{{`. {-   .-~`              /
    .          !:       .\\?.{\   :`      .          :!
    \ :         `      -~!{:!!!\ ~     :!`         .>!
    '  ~          '    '{!!!{!!!t                 ! !!
     '!  !.            {!!!!!!!!!              .~ {~!
      ~!!..`~:.       {!!!!!!!!!!:          .{~ :LS{
       `!!!!!!h:!?!!!!!!!!!!!!!(!!!!::..-~~` {!!!!.
         4!!!!!!!!!!!!!!!!!!!!!~!{!~!!!!!!!!!!!!'
          `!!!!!!!!!!!!!!!!!!!!(~!!!!!!!!!!!!!~
            `!!!!!!!!!!!{\``!!``(!!!!!!!!!~~  .
             `!!!!!!!!!!!!!!!!!!!!!!!!(!:
               .!!!!!!!!!!!!!!!!!!!!!\~
               .`!!!!!!!/`.;;~;;`~!! '
                 -~!!!!!!!!!!!!!(!!/ .
                    `!!!!!!!!!!!!!!'
                      `\!!!!!!!!!~
\033[0;34m

  <action>
  %s
  <location>
  %s
\033[0m
",
sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{action}})),
# <type>
#  %s
#sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{type}})),
sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{location}})));



}

1;




sub  getCommands  {
my  @c  =  keys  $descriptions->{action};
foreach  my  $ele  (@c){
  my  $s  ={};
  $cmd->{$ele}->{cmds}  =  $s;
  foreach  (keys  %{$descriptions->{location}}){
  $s->{$_}->{cmds}  =  {};
  }
}
  return  $cmd;
}


sub  setDir{
  my  $dir  =  shift;
  if(-d  $dir){
  $TOP  =  $dir;
  }
}
sub  checkStructures{
  use  AI::MicroStructure;
  our  $meta  =  AI::MicroStructure->new();
  our  @t  =  $meta->structures;
  my  $number_of_things  =  scalar  @t;
  #  create  the  progress  bar  object
  #  my  $progress  =  Term::ProgressBar::Simple->new(  $number_of_things  );
  #  loop
  foreach  my  $th  (@t)  {
  if  ($th  =~/$search/  ||  $search  eq  ""){
  emit  ("Checking  $th  \n")
  }
  #  increment  the  progress  bar  object  to  tell  it  a  step  has  been  taken.
  #  $progress++;
  }
  }
  #  See  also  use  of  '$progress  +=  $number'  later  in  pod
  sub  sx  {
  no  warnings;
  my  (  @res  )  =  @_;
  my  ($i,  $t,  $_)  =  (undef,"",undef);
  for  (  @res  )  {  tr/a-zA-Z//cd;  tr/a-zA-Z/A-ZA-Z/s;
  ($i,$t)  =  /(.)(.*)/;
  $t  =~  tr/BFPVCGJKQSXZDTLMNRAEHIOUWY/111122222222334556/sd;
  $_  =  substr(($i||'Z').$t.'000',  0,  4  );
  }
  wantarray  ?  @res  :  $res[0];
}
sub  translate  {
  return  unless  -f;
  @check  =  ();
  (my  $rel_name  =  $File::Find::name)  =~  s{./*/*}{}xs;
  my  $first  =  "";
  my  $xname  =  $rel_name;
  $xname  =  pop  [split("/",$rel_name)];
  my  $remove  =  shift  [split("/",$rel_name)];
  $xname  =~  s/([s|S]pringer.|.pdf|The|micro|relations|.json|$remove)/-/gui;
  my  @sy  =  split(/(\.|\(|\)|\_|\  |,|-)/,$xname);
  foreach(@sy){
  push  @check,lc  $_  unless(length($_)<=2);
  }
  @sy  =  App::DrKnow::sx(@check);
  @sy  =  grep{!/Z000/}@sy;
  if  (/\.html$/)  {
  }
  elsif  (/\.pdf$/){
  my  $s  =  join("_",@sy);
  $s  =  "empty"  unless($s);
  my  $name=sprintf("%s\t%s",$s,$rel_name);
  $files->{pdf}->{$s}=$rel_name;#=>{name=>$rel_name,check=>\@check}};
  }elsif(/\.json$/)  {
  my  $s  =  join("_",@sy);
  $s  =  "empty"  unless($s);
  my  $name=sprintf("%s\t%s",$s,$rel_name);
  $files->{json}->{$s}=$rel_name;#={$rel_name=>{name=>$rel_name,check=>\@check}};
  }elsif  (/\.ltx$/)  {
  }elsif  (/^AI*\.pm$/)  {
  }elsif  (/\.txt$/)  {
  my  $s  =  join("_",@sy);
  $s  =  "empty"  unless($s);
  my  $name=sprintf("%s\t%s",$s,$rel_name);
  $files->{txt}->{$s}=$rel_name;#={$rel_name=>{name=>$rel_name,check=>\@check}};
  }else{
  }
}
sub  convertJson  {
my  $self  =  shift;
my  $file  =  shift;
return  unless(-f  $file);
  my  @lines  =  ();
  my  $filename  =  sprintf("%s",$file);
  open(IN,$filename)  or  warn  "Error:  couldn't  open  file  $filename  :  $!\n";
  my  $lines=join("",<IN>);
  close  (IN);
  my  $sense  =  JSON::XS->new->pretty(1)->decode($lines);
  return  $sense;
}
sub  createJsonFile{
  my  $self  =  shift;
  my  $uri  =  shift;
  my  $json  =  shift;
open  (MYFILE,sprintf('>%s.json',$uri));
print  MYFILE  encode_json($json);
close  (MYFILE);
}
sub  decruft  {
  my  $self  =  shift;
  my($file)  =  @_;
  return  unless(-f  $file);
  my($cruftSet)  =  q{%§&|#[^+*(  ]),'";  };
  my  $clean  =  $file;
  $clean=~s/\Q$_//g  for  split("",$cruftSet);
#  system("mv  '$file'  $clean")  unless($file  eq  $clean);
  return  $clean;
}
sub  convertPdf  {
my  $self  =  shift;
my  $file  =  shift;
return  unless(-f  $file);
  my  $dir  =  $self->{tempdir};
  my  $output_dir  =  $dir;
  my  $id  =  md5_hex($file);
  my  $name  =  pop  [split("/",$file)];
  my  $string  =  `$pdftk  @{[quotemeta($file)]}  dump_data  output  -`;
  my(  $last_page  )  =  $string  =~  m/NumberOfPages:  (\d+)/;
  my  $index  =  File::Spec->catfile(  $dir,"$name.meta");
  open  my  $ih,  '>',  $index  or  warn  "Can't  write  $index  ($!)\n";
  print  $ih  $string;
  close  $ih;
  say  "last  page  is  $last_page";
  `pdftotext  @{[quotemeta($file)]}  '$dir/$name.txt'`;

   next unless($last_page);

  my  $lines  =  `wc  -l  '$dir/$name.txt'`;
  my  $s  =  sprintf  "%d",($lines/$last_page);
  `micro-dict  '$dir/$name.txt'  |  data-freq  >  '$dir/$name-all.freq'`;
  #`split  -l  $s  '$name.txt'  '$name.new'`;
  my  @files  =  split(/\n/,`cat  '$dir/$name.txt'`);
#  my  @files  =  split(/^/,`ls  *  |  egrep  "^$name.*.new.*"`);
  my  $buff  =  "";
  my  $pages  =  {};
  my  $i  =0;
  my  $x=0;
  foreach(@files)  {
  $buff.="\n".$_;
  $i++;
  if($s<=$i  &&  $_=~/[a-z|A-Z|0-9]/){
#  print  $_."\n"  unless();
  my  $next  =  $buff;
  $next  =~s/\n/  /g;
  $next  =~s/"//g;
  if(defined  $opts{deep}  &&  $opts{deep}==1){
  $pages->{$x."_".md5_hex($x)}={text=>$buff,dict=>[split("\n",`bash  micro-dict  "$next"  |  data-freq  --limit  10  |  tr  -d  "  "  |  tr  ":"  "="`)]};
  }else{
  $pages->{$x."_".md5_hex($x)}={text=>$buff};
  }
  $i=0;
  $x++;
  $buff="";
  }
  }
  $self->createJsonFile(sprintf("%s/%s",$dir,$name),$pages);
  return  $pages;
}
sub  invoke  {
my  $self  =  shift;
my  $type  =  shift  ||  "pdf";
find(\&translate,  sprintf("/%s",$opts{directory}));
if($opts{verbose}==1){
$search  =  sprintf("%s",join("|",split("\n",`micrownet  $opts{content}`)));
$search  =~  s/\n/\|/g;
$search  =~  s/ /|/g;
$search  =  substr($search,0,length($search)-1);
}else{
  $search  =  $opts{content};
}
#emit($search);
foreach(sort{$a  cmp  $b}  keys  %{$files->{$type}}){
  my  $find  =  App::DrKnow::sx(($search));
  my  $show  =  $files->{$type}->{$_};
  if($show  =~  m/($search)/gui  ||
  $files->{$type}->{$_}  =~  m/($search)/gui){
#  $show  =~  s/\n|  /./g;
  my  $x  =  60-length($_);
  my  $eshow  =  pop  [split('/',$show)];
  emit(sprintf("%s%s%s",$_," "x$x,substr($eshow,0,94)));
  $found->{$type}->{$show}=$show;
#  p@{$files->{$_}};
#  foreach  my  $f(@{$files->{$_}}){
  #  }
  }else{
  }
};
return  $files->{$type};
}



  my  $data  =  {};
  my  $app  =  App::DrKnow->new(
#     ramdisk => {
#           type => 'tmpfs',
#           size => '20m',   # 20 MB
#       },
);
  $app->checkStructures();

  print Dumper $app->invoke();
  print Dumper $app;
  p $app;
1;

__DATA__


#!/usr/bin/perl
package App::DrKnow;
use  strict;
use  warnings;
use  Encode;
our  $VERSION  =  "0.001";
my($cruftSet)  =  q{]),.'";};  #'#
use  Pod::Usage  qw(pod2usage);
use  Cwd;
use  Env  qw(PWD);
use  IO::File;
use File::Spec::Functions;
use File::Spec;
use  File::Path;
use  File::Basename;
use  File::Temp  qw(tempfile  tempdir);
use  File::Find;
use  Storable  qw(lock_store  lock_retrieve  freeze  thaw  dclone);
use  Statistics::Basic  qw(:all);
use  Data::Dumper;
use  Data::Printer;
use  Parallel::Iterator  qw(  iterate  );
use  AnyEvent::Subprocess::Easy  qw(qx_nonblock);
use  Getopt::Long;
use  Digest::MD5  qw(md5_hex);



use  Term::ProgressBar::Simple;
use  Term::ProgressBar;
use  Term::Emit  qw/:all/,  {-bullets  =>  ["  *  ",  "  +  ",  "  -  ",  "  "],
  -color  =>  1,
  -closestat  =>  "CATEGORY",
  -fh  =>  *STDOUT,
  -width=>180};
use  Parallel::Runner;
use  common::sense;
use  JSON;
use  AI::MicroStructure::WordBlacklist;
use  Term::ShellUI;
use  Term::Complete;
use  Log::Log4perl  qw(:easy);
use  Log::Log4perl::Util;
our  $s=AI::MicroStructure::WordBlacklist::getStopWords('en');
our  @stop  =  keys  %$s;
our  $stop  =  join("|",@stop);
use  Time::HiRes  qw(  usleep  );
use  vars  qw(@ISA);
our  $found  =  {};
our  $files={};
our  @check  =  ();
our  $ms  =  AI::MicroStructure->new();
our  $state  =  AI::MicroStructure::Util::config();
our  $config  =  $state->{cfg};

use Cwd;
use Getopt::Long;
use Term::ShellUI;
use AI::MicroStructure;
use AI::MicroStructure::Object;
use AI::MicroStructure::ObjectSet;
use Log::Log4perl qw(:easy);
use Log::Log4perl::Util;
our  $ms  =  AI::MicroStructure->new();
our  $state  =  AI::MicroStructure::Util::config();

our  $curSysDate  =  `date  +"%F"`;
     $curSysDate=~  s/\n//g;


use  Time::HiRes  qw(  usleep  );
use  vars  qw(@ISA);
our  $found  =  {};
our  $files={};
our  @check  =  ();
our $cache = {};
our  %opts  =  (categorys=>"biology",
                content=>"plant",
                verbose=>0,
                deep=>0,
                directory=>$ms->{state}->{cfg}->{"default"},
                cache_file=>  sprintf("%s/%s_.cache",
                $ms->{state}->{cfg}->{"default"},
                $curSysDate));

GetOptions  (\%opts,  "cache_file=s","categorys=s","content=s",  "directory=s",  "verbose=i",  "deep=i");

our  $TOP  =  "/media/Elements/media";
     $TOP  =  $opts{directory};

    my  $create  =  -1;
    my  $target_dir  =  $opts{directory};
    $target_dir  =  $TOP  unless(-d  $target_dir);
    my  $TOP_URL  =  "";

confirm(1);

our  $search  =  "";
  if(-d  $opts{directory}){
  $TOP  =  $opts{directory};
  }
  $opts{categorys}=~s/  /|/g;
  $search  =  $opts{categorys}  unless(!$opts{categorys});
our  $pdftk  =  'pdftk';
our  $pdftotext  =  'pdftotext';
my  @name  =();
my  @vals  =();
my  $set  =  {};
our  $type  =  {};
our  $action  =  {};
our  $sep=sprintf("%s%s%s","\n"x  3,"#"  x  70,"\n");

our $VERSION = "0.001";
our $DRY_RUN;
our $CONFIRM;
our $DRY_RUN_MSG;
our $DATA_SNIPPED_LEN = 60;
use constant DISCIPLIN => '0.001-brain.txt.gz';


our $descriptions = {action=>{},type=>{},location=>{}};
    $descriptions->{action} = {
                    'use'     =>"activate something !",
                    'new'     =>"creates something !",
                    'desc'    =>"show a description about something",
                    'delete'  =>"remove something",
                    'list'    =>"lists something",
                     'search'    =>"search something",
                     'change'  =>"modify something",
                     'plot'    =>"create vissualisation of something",
                     'cloudy'  =>"create optimal query surface for something",
};
    $descriptions->{type} = {
    'new'     =>"things you dont have yet",
    'my'      =>"things you have already",
    'related' =>"things which are related to you",
    'expanding' =>"expanding knowledge",
    #'fit'    =>"usefull things",
    };
    $descriptions->{location} = {
      'category'     =>"on your computer",
      'content'     =>"on a distant computer",
     };

our $cmd={"h" =>                { alias => "help", exclude_from_completion => 1 },
                "?" =>          { alias => "help", exclude_from_completion =>1 },
    "quit" =>           { alias => "exit", exclude_from_completion =>1 },
                "help" => {
                        desc =>sub{ print usage();},
                        args => sub { shift->help_args(undef, @_); },
                        method => sub { shift->help_call(undef, @_); }
                },
                "history" => { desc => "Prints the command history",
                        doc => "Specify a number to list the last N lines of history\n" .
                                "Pass -c to clear the command history, " .
                                "-d NUM to delete a single item\n",
                        args => "[-c] [-d] [number]",
                        exclude_from_completion =>1,
                        method => sub { shift->history_call(@_) },
                },
                "exit" => {
                        desc => "Exits the program.",
                        maxargs => 0,
                        exclude_from_completion =>1,
                        method => sub { shift->exit_requested(1); },
                },
                "quit" => {
                        desc => "Quit using Fileman",
                        maxargs => 0,
                        method => sub { shift->exit_requested(1); }, exclude_from_completion => 1,
                },
                # Term::ShellUI normally displays "asdf: unknown command".
                # This shows how to use the default command.  If the user
                # type an unknown command, ShellUI calls '' if it exists.
                '' => {
                        proc => "No command here by that name!\n",
                        desc => "No help for unknown commands.",
                        doc => "Well, here's a little help: don't type them.\n",
                },
        };
our $location = {
  "category" => {
        args => "(path)",
        desc => "use list new",
        proc => sub {
                                                my $self = shift;
                                                my $parms = shift;
                                                print get_cname(@_) .
                                                        ": " . join(" ",@_), "\n";
                                        },
                },
"content" => {
                        args => sub {   },
        desc => $descriptions->{location}->{content},
        proc => sub{  App::DrKnow::invoke(); }}
};

  our %name = (action=>[qw/list use new/],#search get set   change plot cloudy
                          type=>[qw/new my related/],# popular growing fit term
                          location=>[qw/category content/]);



  eval {
      local $^W = 0;
      if(-f $opts{cache_file}){
      $cache = lock_retrieve($opts{cache_file});
      }else{
        lock_store({},$opts{cache_file});
        $cache = lock_retrieve($opts{cache_file});
      }
      $cache = {} unless $cache;
      warn "New cache!\n" unless defined $cache;
  };





sub new {
    my($class, %options) = @_;
    my $self = {
        tmpdir               => undef,
        tar_read_options     => '',
        tar_write_options    => '',
        tar_gnu_read_options => [],
        dirs                 => 0,
        max_cmd_line_args    => 5056,
        ramdisk              => undef,
        %options,
    };
    bless $self, $class;
    $self->{objectSet} = AI::MicroStructure::ObjectSet->new();
    if(defined $self->{ramdisk}) {
        my $rc = $self->ramdisk_mount( %{ $self->{ramdisk} } );
        if(!$rc) {
            LOGDIE "Mounting ramdisk failed";
        }
        $self->{tmpdir} = $self->{ramdisk}->{tmpdir};
    } else {
        $self->{tmpdir} = tempdir($self->{tmpdir} ?
                                        (DIR => $self->{tmpdir}) : ());
    }
    $self->{tardir} = File::Spec->catfile($self->{tmpdir}, "tar");
    mkpath [$self->{tardir}], 0, 0755 or
        LOGDIE "Cannot mkpath $self->{tardir} ($!)";
    $self->{objdir} = tempdir();
    return $self;
}



sub get_cname{

  my @cats = $cache->{categories};
  printf `echo -e "\x1b[1m bold"` for (@cats);
}


sub tardir {
    my($self) = @_;
    return $self->{tardir};
}

sub download {
    my $self = shift;
    my($url) = @_;
    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;
    INFO "download $url";
    _confirm("Downloading $url => ", basename($url)) or return 1;
    require LWP::UserAgent;
    require HTTP::Request;
    require HTTP::Status;
    my $ua = LWP::UserAgent->new();
    my $request = HTTP::Request->new(GET => $url);
    my $response = $ua->request($request, basename($_[0]));
    my $rc = $response->code();
    if($rc != HTTP::Status::RC_OK()) {
        LOGCROAK("Cannot download $_[0] (",
                  $response->message(),
                 ")");
    }
    return 1;
}
sub DESTROY {
    my($self) = @_;
    $self->ramdisk_unmount() if defined  $self->{ramdisk};
    rmtree($self->{objdir}) if defined $self->{objdir};
    rmtree($self->{tmpdir}) if defined $self->{tmpdir};
}


sub getCommands
{
  my @c = keys $descriptions->{action};
  foreach my $ele (@c){
  my $s ={};
  $cmd->{$ele}->{cmds} = $s;
  foreach (keys %{$descriptions->{location}}){
    $s->{$_}->{cmds} = {};
  }
}
return $cmd;
}


sub bin_find {
    my($exe) = @_;
    my @paths = split /:/, $ENV{PATH};
    push @paths,
         "/usr/bin",
         "/bin",
         "/usr/sbin",
         "/opt/bin",
         "/ops/csw/bin",
         ;
    for my $path ( @paths ) {
        my $full = File::Spec->catfile($path, $exe);
            return $full if -x $full;
    }
    return undef;
}
sub confirm {
    my($on) = @_;
    $CONFIRM = $on;
}
sub _confirm {
    my($msg) = @_;
    if($DRY_RUN) {
        INFO "$msg $DRY_RUN_MSG";
        return 0 if $DRY_RUN;
    }
    if($CONFIRM) {
        my $answer = ask("$msg ([y]/n)", "y");
        if($answer =~ /^\s*y\s*$/) {
            INFO $msg;
            return 1;
        }
        INFO "$msg (*CANCELLED* as requested)";
        return 0;
    }
    return 1;
}
sub dry_run {
    my($on) = @_;
    if($on) {
        $DRY_RUN     = 1;
        $DRY_RUN_MSG = "(skipped - dry run)";
    } else {
        $DRY_RUN     = 0;
        $DRY_RUN_MSG = "";
    }
}
sub ask {
##################################################
    my ($prompt, $default) = @_;
    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;
    if(@_ != 2) {
        LOGCROAK("ask() called with wrong # of args");
    }
  print STDERR "$prompt [$default]> "
        or die "Couldn't write STDERR: ($!)";
    my $value = <STDIN>;
    chomp $value;
    $value = $default if $value eq "";
    return $value;
}
###############################################
sub mkd {
###############################################
    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;
    _confirm "mkd @_" or return 1;
    INFO "mkpath @_";
    mkpath @_ or
        LOGCROAK("Cannot mkdir @_ ($!)");
}

sub usage {


  # create some things to loop over


printf("mount -t tmpfs -o size=20m tmpfs /mnt/myramdisk
             i!~!!))!!!!!!!!!!!!!!!!!!!!!!!!
          i!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
       i!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    '!h!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  '!!`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
   /!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
' ':)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ~:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
..!!!!!\!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 `!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ~ ~!!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!~
~~'~{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:'~
{-{)!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:!
`!!!!{!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!':!!!
' {!!!{>)`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)!~..
:!{!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -!!:
    ~:!4~/!!!!!!!!!!!!!!!!!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!
     :~!!~)(!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ``~!!).~!!!!!!!!!!!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:
            ~  '!\!!!!!!!!!!(!!!!!!!!!!!!!!!!!!!!!!4!!!~:
           '      '--`!!!!!!!!/:\!!{!!((!~.~!!`?~-      :
              ``-.    `~!{!`)(>~/ \~                   :
   .                \  : `{{`. {-   .-~`              /
    .          !:       .\\?.{\   :`      .          :!
    \ :         `      -~!{:!!!\ ~     :!`         .>!
    '  ~          '    '{!!!{!!!t                 ! !!
     '!  !.            {!!!!!!!!!              .~ {~!
      ~!!..`~:.       {!!!!!!!!!!:          .{~ :LS{
       `!!!!!!h:!?!!!!!!!!!!!!!(!!!!::..-~~` {!!!!.
         4!!!!!!!!!!!!!!!!!!!!!~!{!~!!!!!!!!!!!!'
          `!!!!!!!!!!!!!!!!!!!!(~!!!!!!!!!!!!!~
            `!!!!!!!!!!!{\``!!``(!!!!!!!!!~~  .
             `!!!!!!!!!!!!!!!!!!!!!!!!(!:
               .!!!!!!!!!!!!!!!!!!!!!\~
               .`!!!!!!!/`.;;~;;`~!! '
                 -~!!!!!!!!!!!!!(!!/ .
                    `!!!!!!!!!!!!!!'
                      `\!!!!!!!!!~
\033[0;34m

  <action>
  %s
  <location>
  %s
\033[0m
",
sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{action}})),
# <type>
#  %s
#sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{type}})),
sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{location}})));



}

1;




sub  getCommands  {
my  @c  =  keys  $descriptions->{action};
foreach  my  $ele  (@c){
  my  $s  ={};
  $cmd->{$ele}->{cmds}  =  $s;
  foreach  (keys  %{$descriptions->{location}}){
  $s->{$_}->{cmds}  =  {};
  }
}
  return  $cmd;
}


sub  setDir{
  my  $dir  =  shift;
  if(-d  $dir){
  $TOP  =  $dir;
  }
}
sub  checkStructures{
  use  AI::MicroStructure;
  our  $meta  =  AI::MicroStructure->new();
  our  @t  =  $meta->structures;
  my  $number_of_things  =  scalar  @t;
  #  create  the  progress  bar  object
  #  my  $progress  =  Term::ProgressBar::Simple->new(  $number_of_things  );
  #  loop
  foreach  my  $th  (@t)  {
  if  ($th  =~/$search/  ||  $search  eq  ""){
  emit  ("Checking  $th  \n")
  }
  #  increment  the  progress  bar  object  to  tell  it  a  step  has  been  taken.
  #  $progress++;
  }
  }
  #  See  also  use  of  '$progress  +=  $number'  later  in  pod
  sub  sx  {
  no  warnings;
  my  (  @res  )  =  @_;
  my  ($i,  $t,  $_)  =  (undef,"",undef);
  for  (  @res  )  {  tr/a-zA-Z//cd;  tr/a-zA-Z/A-ZA-Z/s;
  ($i,$t)  =  /(.)(.*)/;
  $t  =~  tr/BFPVCGJKQSXZDTLMNRAEHIOUWY/111122222222334556/sd;
  $_  =  substr(($i||'Z').$t.'000',  0,  4  );
  }
  wantarray  ?  @res  :  $res[0];
}
sub  translate  {
  return  unless  -f;
  @check  =  ();
  (my  $rel_name  =  $File::Find::name)  =~  s{./*/*}{}xs;
  my  $first  =  "";
  my  $xname  =  $rel_name;
  $xname  =  pop  [split("/",$rel_name)];
  my  $remove  =  shift  [split("/",$rel_name)];
  $xname  =~  s/([s|S]pringer.|.pdf|The|micro|relations|.json|$remove)/-/gui;
  my  @sy  =  split(/(\.|\(|\)|\_|\  |,|-)/,$xname);
  foreach(@sy){
  push  @check,lc  $_  unless(length($_)<=2);
  }
  @sy  =  App::DrKnow::sx(@check);
  @sy  =  grep{!/Z000/}@sy;
  if  (/\.html$/)  {
  }
  elsif  (/\.pdf$/){
  my  $s  =  join("_",@sy);
  $s  =  "empty"  unless($s);
  my  $name=sprintf("%s\t%s",$s,$rel_name);
  $files->{pdf}->{$s}=$rel_name;#=>{name=>$rel_name,check=>\@check}};
  }elsif(/\.json$/)  {
  my  $s  =  join("_",@sy);
  $s  =  "empty"  unless($s);
  my  $name=sprintf("%s\t%s",$s,$rel_name);
  $files->{json}->{$s}=$rel_name;#={$rel_name=>{name=>$rel_name,check=>\@check}};
  }elsif  (/\.ltx$/)  {
  }elsif  (/^AI*\.pm$/)  {
  }elsif  (/\.txt$/)  {
  my  $s  =  join("_",@sy);
  $s  =  "empty"  unless($s);
  my  $name=sprintf("%s\t%s",$s,$rel_name);
  $files->{txt}->{$s}=$rel_name;#={$rel_name=>{name=>$rel_name,check=>\@check}};
  }else{
  }
}
sub  convertJson  {
my  $self  =  shift;
my  $file  =  shift;
return  unless(-f  $file);
  my  @lines  =  ();
  my  $filename  =  sprintf("%s",$file);
  open(IN,$filename)  or  warn  "Error:  couldn't  open  file  $filename  :  $!\n";
  my  $lines=join("",<IN>);
  close  (IN);
  my  $sense  =  JSON::XS->new->pretty(1)->decode($lines);
  return  $sense;
}
sub  createJsonFile{
  my  $self  =  shift;
  my  $uri  =  shift;
  my  $json  =  shift;
open  (MYFILE,sprintf('>%s.json',$uri));
print  MYFILE  encode_json($json);
close  (MYFILE);
}
sub  decruft  {
  my  $self  =  shift;
  my($file)  =  @_;
  return  unless(-f  $file);
  my($cruftSet)  =  q{%§&|#[^+*(  ]),'";  };
  my  $clean  =  $file;
  $clean=~s/\Q$_//g  for  split("",$cruftSet);
#  system("mv  '$file'  $clean")  unless($file  eq  $clean);
  return  $clean;
}
sub  convertPdf  {
my  $self  =  shift;
my  $file  =  shift;
return  unless(-f  $file);
  my  $dir  =  $self->{tempdir};
  my  $output_dir  =  $dir;
  my  $id  =  md5_hex($file);
  my  $name  =  pop  [split("/",$file)];
  my  $string  =  `$pdftk  @{[quotemeta($file)]}  dump_data  output  -`;
  my(  $last_page  )  =  $string  =~  m/NumberOfPages:  (\d+)/;
  my  $index  =  File::Spec->catfile(  $dir,"$name.meta");
  open  my  $ih,  '>',  $index  or  warn  "Can't  write  $index  ($!)\n";
  print  $ih  $string;
  close  $ih;
  say  "last  page  is  $last_page";
  `pdftotext  @{[quotemeta($file)]}  '$dir/$name.txt'`;

   next unless($last_page);

  my  $lines  =  `wc  -l  '$dir/$name.txt'`;
  my  $s  =  sprintf  "%d",($lines/$last_page);
  `micro-dict  '$dir/$name.txt'  |  data-freq  >  '$dir/$name-all.freq'`;
  #`split  -l  $s  '$name.txt'  '$name.new'`;
  my  @files  =  split(/\n/,`cat  '$dir/$name.txt'`);
#  my  @files  =  split(/^/,`ls  *  |  egrep  "^$name.*.new.*"`);
  my  $buff  =  "";
  my  $pages  =  {};
  my  $i  =0;
  my  $x=0;
  foreach(@files)  {
  $buff.="\n".$_;
  $i++;
  if($s<=$i  &&  $_=~/[a-z|A-Z|0-9]/){
#  print  $_."\n"  unless();
  my  $next  =  $buff;
  $next  =~s/\n/  /g;
  $next  =~s/"//g;
  if(defined  $opts{deep}  &&  $opts{deep}==1){
  $pages->{$x."_".md5_hex($x)}={text=>$buff,dict=>[split("\n",`bash  micro-dict  "$next"  |  data-freq  --limit  10  |  tr  -d  "  "  |  tr  ":"  "="`)]};
  }else{
  $pages->{$x."_".md5_hex($x)}={text=>$buff};
  }
  $i=0;
  $x++;
  $buff="";
  }
  }
  $self->createJsonFile(sprintf("%s/%s",$dir,$name),$pages);
  return  $pages;
}
sub  invoke  {
my  $self  =  shift;
my  $type  =  shift  ||  "pdf";
find(\&translate,  sprintf("/%s",$opts{directory}));
if($opts{verbose}==1){
$search  =  sprintf("%s",join("|",split("\n",`micrownet  $opts{content}`)));
$search  =~  s/\n/\|/g;
$search  =~  s/  /|/g;
$search  =  substr($search,0,length($search)-1);
}else{
  $search  =  $opts{content};
}
#emit($search);
foreach(sort{$a  cmp  $b}  keys  %{$files->{$type}}){
  my  $find  =  App::DrKnow::sx(($search));
  my  $show  =  $files->{$type}->{$_};
  if($show  =~  m/($search)/gui  ||
  $files->{$type}->{$_}  =~  m/($search)/gui){
#  $show  =~  s/\n|  /./g;
  my  $x  =  60-length($_);
  my  $eshow  =  pop  [split('/',$show)];
  emit(sprintf("%s%s%s",$_,"  "x$x,substr($eshow,0,94)));
  $found->{$type}->{$show}=$show;
#  p@{$files->{$_}};
#  foreach  my  $f(@{$files->{$_}}){
  #  }
  }else{
  }
};
return  $files->{$type};
}
sub  trim
{
  my  $string  =  shift;
  $string  =  ""  unless  $string;
  $string  =~  s/^\s+//;
  $string  =~  s/\s+$//;
  $string  =~  s/\t//;
  $string  =~  s/^\s//;
  $string  =~  s/^->//;
  $string  =~  s/^=>//;
  return  $string;
}
sub  action  {
  my  $self  =  shift;
  my($url)  =  @_;
  local  $Log::Log4perl::caller_depth  =
  $Log::Log4perl::caller_depth  +  1;
  INFO  "download  $url";
  _confirm("Downloading  $url  =>  ",  basename($url))  or  return  1;
  return  0;
}
  my  $data  =  {};
  my  $app  =  App::DrKnow->new();
  $app->checkStructures();
  foreach  my  $t(qw/pdf  json/)  {
  Term::Emit::setopts(-closestat  =>  "SOURCE");
  printf("%s\n","@"x185);
  printf("%s%s","  "x80,"$t  "x15);
  printf("%s\n\n","  "x90);
  $app->invoke($t);
  Term::Emit::setopts(-closestat  =>  "COPY  DONE");
  my  @keyd  =  keys  %{$found->{$t}};
  my  $runner  =  Parallel::Runner->new($#keyd);
  foreach(@keyd){
  $runner->run(  sub  {
  my  $n=pop  [split("/",$_)];
  $n  =~  s/\s//;
  my  $f  =  sprintf('%s/%s.pdf',$app->{tempdir},$n);
  system(sprintf("IFS=\$'\n';  cp  '/$_'  '%s/%s'",$app->{tempdir},$n))unless($t!~/json/);
#  system(sprintf("IFS=\$'\n';  pdftotext  -q  -htmlmeta  -raw  '/$_'  '%s/%s.html'  ",$app->{tempdir},$n))unless($t!~/pdf/);
#  system(sprintf("IFS=\$'\n';  pdftotext  -q  '/$_'  '%s/%s.txt'  ",$app->{tempdir},$n))unless($t!~/pdf/);
#  system(sprintf("micro-dict  '%s*txt'",$app->{tempdir},$n))unless($t!~/pdf/);
#  system(sprintf("IFS=\$'\n';  pdftotext  -q  '%s/%s.pdf'  '%s/%s.txt'  ",$app->{tempdir},$n,$app->{tempdir},$n))  unless($t!~/pdf/);
  #  system(sprintf("IFS=\$'\n';  rm  '%s/%s.pdf'  ",$app->{tempdir},$n))unless($t!~/pdf/);
  $f=~  s/.pdf$/.txt/g;
  $data->{$_}=$app->convertPdf("/$_")  unless($t!~/pdf/);
  #pdftotext  '/$_'  %s/%s.pdf",$app->{tempdir},$n))unless($t!~/pdf/);
  $data->{$_}=$app->convertJson("/$_")  unless($t!~/json/);
#  emit($data->{$_});
}  );
  }
  $runner->finish;
  }
  printf("%s\n","@"x190);
#  printf("%s","\n"x150);
#  if($app->action("use  sources  as  content")){
  #  my  $term  =  new  Term::ShellUI(commands  =>getCommands(),
  #  history_file  =>  '~/.active-memory');
  #  $term->prompt(sub  {"active-memory>  "  });
  #  $term->run();
#  }else{
  #  _confirm("Downloading  $target_dir  =>  ",  basename($target_dir));
#  print  usage();
  #}
#my  $analyzer  =  AI::Classifier::Text::Analyzer->new();
p  $data;
p  $app;
1;
__DATA__
#  App::DrKnow::checkStructures();
#
  App::DrKnow::checkStructures();
  App::DrKnow::envoke();
1;
__DATA__
our  @check  =  ();




dump/cook/tmp/cookbook_other/threads/thread_usage:
