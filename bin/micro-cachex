#!/usr/bin/perl -w
package App::DrKnow;

use 5.006;
use strict;
use warnings;

our $VERSION = "0.001";
use Pod::Usage qw(pod2usage);
use Cwd;
use Env qw(PWD);
use IO::File;
use File::Path;
use File::Basename;
use File::Temp qw(tempfile tempdir);
use File::Find;

use JSON::XS;
use Storable qw(lock_store lock_retrieve freeze thaw dclone);
use Statistics::Basic qw(:all);
use Data::Dumper;
use Data::Printer;
use Data::Freq;

use Getopt::Long;
use Digest::MD5 qw(md5_hex);
use Term::ProgressBar::Simple;
use Term::ProgressBar;
use Term::Emit qw/:all/, {-bullets => [" * ", " + ", " - ", "   "],
                        -color     => 1,
                        -closestat => "CATEGORY",
                        -fh => *STDOUT,
                        -width=>180};

use Term::ShellUI;
use Term::Complete;

use Log::Log4perl qw(:easy);
use Log::Log4perl::Util;


use Time::HiRes qw( usleep );
use vars qw(@ISA);
our $found = {};
our $files={};
our @check = ();

our $ms = AI::MicroStructure->new();
our $state  = AI::MicroStructure::Util::config();
our $config = $state->{cfg};




our $curSysDate = `date +"%F"`;
    $curSysDate=~ s/\n//g;



our $cache={};




our %opts = (categorys=>"biology",
             content=>"plant",
             verbose=>0,
             directory=>$ms->{state}->{cfg}->{"default"},
             cache_file =>  sprintf("%s/%s_.cache",
             $ms->{state}->{cfg}->{"default"},
             $curSysDate));

GetOptions (\%opts, "cache_file=s","categorys=s","content=s", "directory=s", "verbose=i");

eval {
    local $^W = 0;
    if(-f $opts{cache_file}){
    $cache = lock_retrieve($opts{cache_file});
    }else{
      lock_store({},$opts{cache_file});
      $cache = lock_retrieve($opts{cache_file});

    }
    $cache = {} unless $cache;

    warn "New cache!\n" unless defined $cache;
};




our $TOP = "/media/Elements/media";
    $TOP = $opts{directory};

my $create = -1;
my $target_dir = $opts{directory};

   $target_dir = $TOP unless(-d $target_dir);

my $TOP_URL = "";



our %name = (action=>[qw/list use new/],#search get set   change plot cloudy
                        type=>[qw/new my related/],# popular growing fit term
                        location=>[qw/category content/]);



my @name =();
my @vals =();

my $set = {};
our $type = {};
our $action = {};
our $sep=sprintf("%s%s%s","\n"x 3,"#" x 70,"\n");




our $DRY_RUN;
our $CONFIRM;
our $DRY_RUN_MSG;
our $DATA_SNIPPED_LEN = 60;



sub new {
    my($class, %options) = @_;

    my $self = {
        tempdir=>tempdir(),
        %options,
    };

    bless $self, $class;

    return $self;
}


BEGIN{


  }
INIT{

    #emit($search);

  }


sub tardir {

    my($self) = @_;

    return $self->{tardir};
}


sub download {

    my $self = shift;
    my($url) = @_;

    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;

    INFO "download $url";

    _confirm("Downloading $url => ", basename($url)) or return 1;

    require LWP::UserAgent;
    require HTTP::Request;
    require HTTP::Status;

    my $ua = LWP::UserAgent->new();
    my $request = HTTP::Request->new(GET => $url);
    my $response = $ua->request($request, basename($_[0]));
    my $rc = $response->code();

    if($rc != HTTP::Status::RC_OK()) {
        LOGCROAK("Cannot download $_[0] (",
                  $response->message(),
                 ")");
    }

    return 1;
}



#dry_run(0);
confirm(1);
our $search =  "";


    if(-d $opts{directory}){
      $TOP =  $opts{directory};
    }

    $opts{categorys}=~s/ /|/g;
    $search = $opts{categorys} unless(!$opts{categorys});




###############################################
sub dry_run {
###############################################
    my($on) = @_;

    if($on) {
        $DRY_RUN     = 1;
        $DRY_RUN_MSG = "(skipped - dry run)";
    } else {
        $DRY_RUN     = 0;
        $DRY_RUN_MSG = "";
    }
}

###############################################
sub confirm {
###############################################
    my($on) = @_;

    $CONFIRM = $on;
}

###########################################
sub _confirm {
###########################################
    my($msg) = @_;

    if($DRY_RUN) {
        INFO "$msg $DRY_RUN_MSG";
        return 0 if $DRY_RUN;
    }

    if($CONFIRM) {
        my $answer = ask("$msg ([y]/n)", "y");
        if($answer =~ /^\s*y\s*$/) {
            INFO $msg;
            return 1;
        }

        INFO "$msg (*CANCELLED* as requested)";
        return 0;
    }

    return 1;
}

##################################################
sub ask {
##################################################
    my ($prompt, $default) = @_;

    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;

    if(@_ != 2) {
        LOGCROAK("ask() called with wrong # of args");
    }

  print STDERR "$prompt [$default]> "
        or die "Couldn't write STDERR: ($!)";

    my $value = <STDIN>;
    chomp $value;

    $value = $default if $value eq "";

    return $value;
}


###############################################
sub mkd {
###############################################

    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;

    _confirm "mkd @_" or return 1;

    INFO "mkpath @_";

    mkpath @_ or
        LOGCROAK("Cannot mkdir @_ ($!)");
}


our $descriptions = {action=>{},type=>{},location=>{}};
    $descriptions->{action} = {
                    'use'     =>"activate something !",
                    'new'     =>"creates something !",
                    #  'desc'    =>"show a description about something",
                    #  'delete'  =>"remove something",
                    'list'    =>"lists something",
                    # 'search'    =>"search something",
                    # 'change'  =>"modify something",
                    # 'plot'    =>"create vissualisation of something",
                    # 'cloudy'  =>"create optimal query surface for something",
};

$descriptions->{type} =
{

'new'     =>"things you dont have yet",
'my'      =>"things you have already",
'related' =>"things which are related to you",
'expanding' =>"expanding knowledge",
#'fit'    =>"usefull things",
};

$descriptions->{location} =
{
  'category'     =>"on your computer",
  'content'     =>"on a distant computer",

};

my $usage=usage();


sub get_cname{


p @_;

my @cats = $cache->{categories};

printf `echo -e "\x1b[1m bold"` for (@cats);


}


our $cmd={"h" =>                { alias => "help", exclude_from_completion => 1 },
                "?" =>          { alias => "help", exclude_from_completion =>1 },
    "quit" =>           { alias => "exit", exclude_from_completion =>1 },
                "help" => {
                        desc =>sub{ print usage();},
                        args => sub { shift->help_args(undef, @_); },
                        method => sub { shift->help_call(undef, @_); }
                },
                "history" => { desc => "Prints the command history",
                        doc => "Specify a number to list the last N lines of history\n" .
                                "Pass -c to clear the command history, " .
                                "-d NUM to delete a single item\n",
                        args => "[-c] [-d] [number]",
                        exclude_from_completion =>1,
                        method => sub { shift->history_call(@_) },

                },
                "exit" => {
                        desc => "Exits the program.",
                        maxargs => 0,
                        exclude_from_completion =>1,
                        method => sub { shift->exit_requested(1); },

                },
                "quit" => {
                        desc => "Quit using Fileman",
                        maxargs => 0,
                        method => sub { shift->exit_requested(1); }, exclude_from_completion => 1,
                },

                # Term::ShellUI normally displays "asdf: unknown command".
                # This shows how to use the default command.  If the user
                # type an unknown command, ShellUI calls '' if it exists.
                '' => {
                        proc => "No command here by that name!\n",
                        desc => "No help for unknown commands.",
                        doc => "Well, here's a little help: don't type them.\n",
                },

        };


our $location = {
  "category" => {
        args => "(path)",
        desc => "use list new",
        proc => sub {
                                                my $self = shift;
                                                my $parms = shift;
                                                print get_cname(@_) .
                                                        ": " . join(" ",@_), "\n";
                                        },
                },
"content" => {
                        args => sub {   },
        desc => $descriptions->{location}->{content},
        proc => sub{  App::DrKnow::invoke(); }}
};


### pod & usage in one
sub usage {


  # create some things to loop over


printf("
             i!~!!))!!!!!!!!!!!!!!!!!!!!!!!!
          i!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
       i!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    '!h!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  '!!`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
   /!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
' ':)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ~:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
..!!!!!\!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 `!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ~ ~!!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!~
~~'~{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:'~
{-{)!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:!
`!!!!{!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!':!!!
' {!!!{>)`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)!~..
:!{!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -!!:
    ~:!4~/!!!!!!!!!!!!!!!!!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!
     :~!!~)(!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ``~!!).~!!!!!!!!!!!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:
            ~  '!\!!!!!!!!!!(!!!!!!!!!!!!!!!!!!!!!!4!!!~:
           '      '--`!!!!!!!!/:\!!{!!((!~.~!!`?~-      :
              ``-.    `~!{!`)(>~/ \~                   :
   .                \  : `{{`. {-   .-~`              /
    .          !:       .\\?.{\   :`      .          :!
    \ :         `      -~!{:!!!\ ~     :!`         .>!
    '  ~          '    '{!!!{!!!t                 ! !!
     '!  !.            {!!!!!!!!!              .~ {~!
      ~!!..`~:.       {!!!!!!!!!!:          .{~ :LS{
       `!!!!!!h:!?!!!!!!!!!!!!!(!!!!::..-~~` {!!!!.
         4!!!!!!!!!!!!!!!!!!!!!~!{!~!!!!!!!!!!!!'
          `!!!!!!!!!!!!!!!!!!!!(~!!!!!!!!!!!!!~
            `!!!!!!!!!!!{\``!!``(!!!!!!!!!~~  .
             `!!!!!!!!!!!!!!!!!!!!!!!!(!:
               .!!!!!!!!!!!!!!!!!!!!!\~
               .`!!!!!!!/`.;;~;;`~!! '
                 -~!!!!!!!!!!!!!(!!/ .
                    `!!!!!!!!!!!!!!'
                      `\!!!!!!!!!~
\033[0;34m

  <action>
  %s
  <location>
  %s
\033[0m
",
sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{action}})),
# <type>
#  %s
#sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{type}})),
sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{location}})));



}


sub getCommands {

my @c = keys $descriptions->{action};

foreach my $ele (@c){

                                my $s ={};
                                $cmd->{$ele}->{cmds} = $s;

                                foreach (keys %{$descriptions->{location}}){

                                  $s->{$_}->{cmds} = {};


                                }


}

        return $cmd;
}




sub setDir{

    my $dir = shift;
    if(-d $dir){

      $TOP = $dir;

    }

}
sub  checkStructures{


    use AI::MicroStructure;
    our $meta = AI::MicroStructure->new();
    our @t = $meta->structures;



    my $number_of_things = scalar @t;

    # create the progress bar object
   # my $progress = Term::ProgressBar::Simple->new( $number_of_things );

    # loop
    foreach my $th (@t) {
    if ($th =~/$search/ || $search eq ""){
      emit ("Checking $th  \n")
    }


                # increment the progress bar object to tell it a step has been taken.
    #    $progress++;
    }
  }
    # See also use of '$progress += $number' later in pod


  sub sx {

  no warnings;
  my ( @res ) = @_;
  my ($i, $t, $_) = (undef,"",undef);

  for ( @res ) { tr/a-zA-Z//cd; tr/a-zA-Z/A-ZA-Z/s;
      ($i,$t) = /(.)(.*)/;
     $t =~ tr/BFPVCGJKQSXZDTLMNRAEHIOUWY/111122222222334556/sd;
     $_ = substr(($i||'Z').$t.'000', 0, 4 );
  }
  wantarray ? @res : $res[0];
}


sub translate {
  return unless -f;

  @check = ();
  (my $rel_name = $File::Find::name) =~ s{./*/*}{}xs;


  my $first = "";
  my $xname = $rel_name;
  $xname = pop [split("/",$rel_name)];
  my $remove = shift [split("/",$rel_name)];
  $xname =~ s/([s|S]pringer.|.pdf|The|micro|relations|.json|$remove)/-/gui;
  my @sy = split(/(\.|\(|\)|\_|\ |,|-)/,$xname);



  foreach(@sy){
      push @check,lc $_ unless(length($_)<=2);

  }

  @sy = App::DrKnow::sx(@check);

  @sy = grep{!/Z000/}@sy;



  if (/\.html$/) {

  }
  elsif (/\.pdf$/){
  my $s = join("_",@sy);
     $s = "empty" unless($s);
  my $name=sprintf("%s\t%s",$s,$rel_name);


    $files->{pdf}->{$s}=$rel_name;#=>{name=>$rel_name,check=>\@check}};

  }elsif(/\.json$/) {



  my $s = join("_",@sy);
     $s = "empty" unless($s);
  my $name=sprintf("%s\t%s",$s,$rel_name);


    $files->{json}->{$s}=$rel_name;#={$rel_name=>{name=>$rel_name,check=>\@check}};


  }elsif (/\.ltx$/) {
  }elsif (/^AI*\.pm$/) {
  }elsif (/\.txt$/) {

  my $s = join("_",@sy);
     $s = "empty" unless($s);
  my $name=sprintf("%s\t%s",$s,$rel_name);


    $files->{txt}->{$s}=$rel_name;#={$rel_name=>{name=>$rel_name,check=>\@check}};


  }else{

  }

}

sub convertJson {

my $self = shift;
my $file = shift;

return unless(-f $file);

  my @lines = ();
  my $filename = sprintf("%s",$file);
  open(IN,$filename) or warn "Error: couldn't open file $filename : $!\n";

    my $lines=join("",<IN>);

    close (IN);

    my $sense = JSON::XS->new->pretty(1)->decode($lines);


    return $sense;



}

sub invoke {



my $self = shift;


my $type = shift || "pdf";


find(\&translate, sprintf("/%s",$opts{directory}));

if($opts{verbose}==1){
$search = sprintf("%s",join("|",split("\n",`micrownet $opts{content}`)));
$search =~ s/\n/\|/g;
$search =~ s/ /|/g;
$search = substr($search,0,length($search)-1);
}else{
 $search = $opts{content};
}

#emit($search);

foreach(sort{$a cmp $b} keys %{$files->{$type}}){
  my $find = App::DrKnow::sx(($search));
  my $show = $files->{$type}->{$_};


  if($show =~ m/($search)/gui ||
     $files->{$type}->{$_} =~ m/($search)/gui){


#    $show =~ s/\n| /./g;
    my $x = 60-length($_);
    my $eshow = pop [split('/',$show)];
    emit(sprintf("%s%s%s",$_," "x$x,substr($eshow,0,94)));
    $found->{$type}->{$show}=$show;
#    p@{$files->{$_}};

#  foreach my $f(@{$files->{$_}}){

 # }
 }else{

  }
};



return $files->{$type};

}

sub trim
{
  my $string = shift;

  $string =  "" unless  $string;
  $string =~ s/^\s+//;
  $string =~ s/\s+$//;
  $string =~ s/\t//;
  $string =~ s/^\s//;
  $string =~ s/^->//;
  $string =~ s/^=>//;

  return $string;
}

sub action {

    my $self = shift;
    my($url) = @_;

    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;

    INFO "download $url";

    _confirm("Downloading $url => ", basename($url)) or return 1;


    p $self;

    return 0;
}
  my $data = {};
  my  $app = App::DrKnow->new();

      $app->checkStructures();



      foreach my $t(qw/pdf json/) {
        Term::Emit::setopts(-closestat => "SOURCE");
       printf("%s\n","@"x185);
        printf("%s%s"," "x80,"$t "x15);
        printf("%s\n\n"," "x90);
        $app->invoke($t);

        Term::Emit::setopts(-closestat => "COPY DONE");
        foreach(keys %{$found->{$t}}){
          my $n=pop [split("/",$_)];
          system(sprintf(" cp '/$_' '%s/%s.json'",$app->{tempdir},$n))unless($t!~/json/);
          system(sprintf("cp '/$_' '%s/%s.pdf' ",$app->{tempdir},$n))unless($t!~/pdf/);
          system(sprintf("pdftotext '%s/%s.pdf' '%s/%s.txt' ",$app->{tempdir},$n,$app->{tempdir},$n)) unless($t!~/pdf/);

          #pdftotext '/$_' %s/%s.pdf",$app->{tempdir},$n))unless($t!~/pdf/);
           $data->{$_}=$app->convertJson("/$_") unless($t!~/json/);
#          emit($_);
        }

      }
      printf("%s\n","@"x190);
#      printf("%s","\n"x150);



#  if($app->action("use sources as content")){

 #   my $term = new Term::ShellUI(commands =>getCommands(),
  #    history_file => '~/.active-memory');
   #   $term->prompt(sub {"active-memory> " });
    #  $term->run();


#  }else{


 #   _confirm("Downloading $target_dir => ", basename($target_dir));

#    print usage();


  #}


 my $i=0;
        foreach my $txt (split("\n\n",`IFS=\$'\n'; cat $app->{tempdir}/*.txt`)){
          $data->{book}->{$i}=$txt;
          $i++;
        }


p $data;

1;
__DATA__
#  App::DrKnow::checkStructures();
#

  App::DrKnow::checkStructures();
  App::DrKnow::envoke();


1;
__DATA__

our @check = ();
