#!/usr/bin/perl -w

package App::DrKnow;
use strict;
use warnings;
use Getopt::Std;
use Data::Printer;
use Pod::Usage;
use File::Temp qw(tempdir);
use Time::HiRes qw( usleep );
use  Digest::MD5  qw(md5_hex);

use Search::ContextGraph;
use File::Spec::Functions;
use File::Spec;
use File::Path;
use File::Copy;
use File::Find;
use File::Basename;
use Cwd;
use Storable qw(lock_store lock_retrieve freeze thaw dclone);
use Statistics::Basic qw(:all);
use Getopt::Long;
use Term::ShellUI;
use AI::MicroStructure;
use AI::MicroStructure::Object;
use AI::MicroStructure::ObjectSet;
use Log::Log4perl qw(:easy);
use Log::Log4perl::Util;
use AI::MicroStructure::Context;
my  $data={};
my   $TOP  =  "";
use  Term::ProgressBar::Simple;
use Data::Dumper;
use  Term::ProgressBar;
use  Parallel::Runner;
use  common::sense;
use  JSON;
use  AI::MicroStructure::WordBlacklist;
use  Term::ShellUI;
use  Term::Complete;
use  Term::Emit  qw/:all/,  {-bullets  =>  ["  *  ",  "  +  ",  "  -  ",  "  "],
  -color  =>  1,
  -closestat  =>  "DATA",
  -fh  =>  *STDOUT,
  -width=>160};
use  Log::Log4perl  qw(:easy);
use  Log::Log4perl::Util;
my   $s=AI::MicroStructure::WordBlacklist::getStopWords('en');
my   @stop  =  keys  %$s;
my   $stop  =  join("|",@stop);
use  Time::HiRes  qw(  usleep  );
use  vars  qw(@ISA);
my   $found  =  {};
my   $files={};
my   @check  =  ();

my   $state  =  AI::MicroStructure::Util::config();
my   $config  =  $state->{cfg};
my   $pdftk  =  'pdftk';
my   $pdftotext  =  'pdftotext';

#dry_run(0);
confirm(1);
my  $VERSION = "0.001";
my  $DRY_RUN;
my  $CONFIRM;
my  $DRY_RUN_MSG;
my  $DATA_SNIPPED_LEN = 60;
use constant DISCIPLIN => '0.001-brain.txt.gz';


my  $descriptions = {action=>{},type=>{},location=>{}};
    $descriptions->{action} = {
                    'use'     =>"activate something !",
                    'new'     =>"creates something !",
                    'desc'    =>"show a description about something",
                    'delete'  =>"remove something",
                    'list'    =>"lists something",
                     'search'    =>"search something",
                     'change'  =>"modify something",
                     'plot'    =>"create vissualisation of something",
                     'cloudy'  =>"create optimal query surface for something",
};
    $descriptions->{type} = {
    'new'     =>"things you dont have yet",
    'my'      =>"things you have already",
    'related' =>"things which are related to you",
    'expanding' =>"expanding knowledge",
    #'fit'    =>"usefull things",
    };
    $descriptions->{location} = {
      'category'     =>"on ymy  computer",
      'content'     =>"on a distant computer",
     };

my  $cmd={"h" =>                { alias => "help", exclude_from_completion => 1 },
                "?" =>          { alias => "help", exclude_from_completion =>1 },
    "quit" =>           { alias => "exit", exclude_from_completion =>1 },
                "help" => {
                        desc =>sub{ print usage();},
                        args => sub { shift->help_args(undef, @_); },
                        method => sub { shift->help_call(undef, @_); }
                },
                "history" => { desc => "Prints the command history",
                        doc => "Specify a number to list the last N lines of history\n" .
                                "Pass -c to clear the command history, " .
                                "-d NUM to delete a single item\n",
                        args => "[-c] [-d] [number]",
                        exclude_from_completion =>1,
                        method => sub { shift->history_call(@_) },
                },
                "exit" => {
                        desc => "Exits the program.",
                        maxargs => 0,
                        exclude_from_completion =>1,
                        method => sub { shift->exit_requested(1); },
                },
                "quit" => {
                        desc => "Quit using Fileman",
                        maxargs => 0,
                        method => sub { shift->exit_requested(1); }, exclude_from_completion => 1,
                },
                # Term::ShellUI normally displays "asdf: unknown command".
                # This shows how to use the default command.  If the user
                # type an unknown command, ShellUI calls '' if it exists.
                '' => {
                        proc => "No command here by that name!\n",
                        desc => "No help for unknown commands.",
                        doc => "Well, here's a little help: don't type them.\n",
                },
        };
my  $location = {
  "category" => {
        args => "(path)",
        desc => "use list new",
        proc => sub {
                                                my $self = shift;
                                                my $parms = shift;
                                                print get_cname(@_) .
                                                        ": " . join(" ",@_), "\n";
                                        },
                },
"content" => {
                        args => sub {   },
        desc => $descriptions->{location}->{content},
        proc => sub{  App::DrKnow::invoke(); }}
};

  my  %name = (action=>[qw/list use new/],#search get set   change plot cloudy
                          type=>[qw/new my related/],# popular growing fit term
                          location=>[qw/category content/]);

  my  $ms = AI::MicroStructure->new();
  my  $curSysDate = `date +"%F"`;
      $curSysDate=~ s/\n//g;
  my  $cache={};


our $ident = md5_hex(("%s%s",$0,join(" ",@ARGV)));

our %opts = (cache_file =>sprintf("%s/%s_.cache",
               $ms->{state}->{cfg}->{"default"},
               $curSysDate),
             directory        => $ms->{state}->{cfg}->{"default"},
             mime        => "pdf",
             filter        => "micro-relations-",
             match        => "",
             max_cache_age => 5,
             silent=>0,
             full=>0,
             level=>4,
             scope=>2,
             categorys=>"biology",
             content=>"plant",
             deep=>0,
             verbose=>0,
             categorys=>"biology",
             content=>"plant",
             deep=>0,
             verbose=>0,
             );

GetOptions (\%opts, "cache_file=s","match=s","deep=i","categorys=s","content=s",  "verbose=i", "max_cache_age=i" ,"full=i", "filter=s", "mime=s","directory=s","silent=i","level=i","scope=i");


if($#ARGV){  }else{


my $x = 'dialog --backtitle "active-memory - InputBox" --inputbox "Enter a file type (pdf,json,mpg,..), please" 8 52 ';
#$opts{dir}= sprintf `$x`;
if(system $x)  {

}
#$opts{dir} = ;
}

  eval {
      local $^W = 0;
      if(-f $opts{cache_file}){
      $cache = lock_retrieve($opts{cache_file});
      }else{
        lock_store({},$opts{cache_file});
        $cache = lock_retrieve($opts{cache_file});
      }
      $cache = {} unless $cache;
      warn "New cache!\n" unless defined $cache;
  };



    $TOP  =  $opts{directory};
my  $create  =  -1;
my  $target_dir  =  $opts{directory};
  $target_dir  =  $TOP  unless(-d  $target_dir);
my  $TOP_URL  =  "";
my   $search  =  "";
  if(-d  $opts{directory}){
  $TOP  =  $opts{directory};
  }
  $opts{categorys}=~s/  /|/g;
  $search  =  $opts{categorys}  unless(!$opts{categorys});

#print Dumper [ %opts,@ARGV];


sub  new  {
  my($class,  %options)  =  @_;
  my  $self  =  {
  ms=> AI::MicroStructure->new(),
  tempdir=>tempdir(),
  graph=>Search::ContextGraph->new(),
  %options,
  };
  bless  $self,  $class;

#  $self->{graph}->load_from_dir($self->{ms}->{state}->{path}->{"cwd/structures"});




  if(defined  $self->{ramdisk})  {
  my  $rc  =  $self->ramdisk_mount(  %{  $self->{ramdisk}  }  );
  if(!$rc)  {
  LOGDIE  "Mounting  ramdisk  failed";
  }
  $self->{tmpdir}  =  $self->{ramdisk}->{tmpdir};
  }  else  {
  $self->{tmpdir}  =  tempdir($self->{tmpdir}  ?
  (DIR  =>  $self->{tmpdir})  :  ());
  }
  $self->{tardir}  =  File::Spec->catfile($self->{tmpdir},  "tar");
  mkpath  [$self->{tardir}],  0,  0755  or
  LOGDIE  "Cannot  mkpath  $self->{tardir}  ($!)";


  $self->{objdir}  =  File::Spec->catfile($self->{tmpdir},  "objdir");
  mkpath  [$self->{objdir}],  0,  0755  or
  LOGDIE  "Cannot  mkpath  $self->{objdir}  ($!)";
#  $self->{objdir}  =  tempdir();
  return  $self;
}



sub get_cname{

  my @cats = $cache->{categories};
  printf `echo -e "\x1b[1m bold"` for (@cats);
}


sub tardir {
    my($self) = @_;
    return $self->{tardir};
}

sub download {
    my $self = shift;
    my($url) = @_;
    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;
    INFO "download $url";
    _confirm("Downloading $url => ", basename($url)) or return 0;
    require LWP::UserAgent;
    require HTTP::Request;
    require HTTP::Status;
    my $ua = LWP::UserAgent->new();
    my $request = HTTP::Request->new(GET => $url);
    my $response = $ua->request($request, basename($_[0]));
    my $rc = $response->code();
    if($rc != HTTP::Status::RC_OK()) {
        LOGCROAK("Cannot download $_[0] (",
                  $response->message(),
                 ")");
    }
    return 1;
}
sub DESTROY {
    my($self) = @_;
    #$self->ramdisk_unmount() if defined  $self->{ramdisk};
    #rmtree($self->{objdir}) if defined $self->{objdir};
    #rmtree($self->{tmpdir}) if defined $self->{tmpdir};
}


sub getCommands
{
  my @c = keys $descriptions->{action};
  foreach my $ele (@c){
  my $s ={};
  $cmd->{$ele}->{cmds} = $s;
  foreach (keys %{$descriptions->{location}}){
    $s->{$_}->{cmds} = {};
  }
}
return $cmd;
}


sub bin_find {
    my($exe) = @_;
    my @paths = split /:/, $ENV{PATH};
    push @paths,
         "/usr/bin",
         "/bin",
         "/usr/sbin",
         "/opt/bin",
         "/ops/csw/bin",
         ;
    for my $path ( @paths ) {
        my $full = File::Spec->catfile($path, $exe);
            return $full if -x $full;
    }
    return undef;
}
sub confirm {
    my($on) = @_;
    $CONFIRM = $on;
}
sub _confirm {
    my($msg) = @_;
    if($DRY_RUN) {
        INFO "$msg $DRY_RUN_MSG";
        return 0 if $DRY_RUN;
    }
    if($CONFIRM) {
        my $answer = ask("$msg ([y]/n)", "y");
        if($answer =~ /^\s*y\s*$/) {
            INFO $msg;
            return 1;
        }
        INFO "$msg (*CANCELLED* as requested)";
        return 0;
    }
    return 1;
}
sub dry_run {
    my($on) = @_;
    if($on) {
        $DRY_RUN     = 1;
        $DRY_RUN_MSG = "(skipped - dry run)";
    } else {
        $DRY_RUN     = 0;
        $DRY_RUN_MSG = "";
    }
}
sub ask {
##################################################
    my ($prompt, $default) = @_;
    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;
    if(@_ != 2) {
        LOGCROAK("ask() called with wrong # of args");
    }
  print STDERR "$prompt [$default]> "
        or die "Couldn't write STDERR: ($!)";
    my $value = <STDIN>;
    chomp $value;
    $value = $default if $value eq "";
    return $value;
}
###############################################
sub mkd {
###############################################
    local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 1;
    _confirm "mkd @_" or return 1;
    INFO "mkpath @_";
    mkpath @_ or
        LOGCROAK("Cannot mkdir @_ ($!)");
}

sub usage {


  # create some things to loop over


printf("
\033[0;34m
             i!~!!))!!!!!!!!!!!!!!!!!!!!!!!!
          i!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
       i!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    '!h!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  '!!`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
   /!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
' ':)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ~:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
..!!!!!\!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 `!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ~ ~!!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!~
~~'~{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:'~
{-{)!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:!
`!!!!{!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!':!!!
' {!!!{>)`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)!~..
:!{!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -!!:
    ~:!4~/!!!!!!!!!!!!!!!!!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!
     :~!!~)(!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ``~!!).~!!!!!!!!!!!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:
            ~  '!\!!!!!!!!!!(!!!!!!!!!!!!!!!!!!!!!!4!!!~:
           '      '--`!!!!!!!!/:\!!{!!((!~.~!!`?~-      :
              ``-.    `~!{!`)(>~/ \~                   :
   .                \  : `{{`. {-   .-~`              /
    .          !:       .\\?.{\   :`      .          :!
    \ :         `      -~!{:!!!\ ~     :!`         .>!
    '  ~          '    '{!!!{!!!t                 ! !!
     '!  !.            {!!!!!!!!!              .~ {~!
      ~!!..`~:.       {!!!!!!!!!!:          .{~ :LS{
       `!!!!!!h:!?!!!!!!!!!!!!!(!!!!::..-~~` {!!!!.
         4!!!!!!!!!!!!!!!!!!!!!~!{!~!!!!!!!!!!!!'
          `!!!!!!!!!!!!!!!!!!!!(~!!!!!!!!!!!!!~
            `!!!!!!!!!!!{\``!!``(!!!!!!!!!~~  .
             `!!!!!!!!!!!!!!!!!!!!!!!!(!:
               .!!!!!!!!!!!!!!!!!!!!!\~
               .`!!!!!!!/`.;;~;;`~!! '
                 -~!!!!!!!!!!!!!(!!/ .
                    `!!!!!!!!!!!!!!'
                      `\!!!!!!!!!~


  <action>
  %s
  <location>
  %s
\033[0m
",
sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{action}})),
# <type>
#  %s
#sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{type}})),
sprintf("\033[0;31m\t|-%s\033[255;34m",join( "\n\t|-", @{$name{location}})));



}


sub  getCommands  {
my  @c  =  keys  $descriptions->{action};
foreach  my  $ele  (@c){
  my  $s  ={};
  $cmd->{$ele}->{cmds}  =  $s;
  foreach  (keys  %{$descriptions->{location}}){
  $s->{$_}->{cmds}  =  {};
  }
}
  return  $cmd;
}


sub  checkStructures{
  use  AI::MicroStructure;
  my   $meta  =  AI::MicroStructure->new();
  my   @t  =  $meta->structures;
  my  $number_of_things  =  scalar  @t;
  #  create  the  progress  bar  object
  #  my  $progress  =  Term::ProgressBar::Simple->new(  $number_of_things  );
  #  loop
  foreach  my  $th  (@t)  {
  if  ($th  =~/$search/  ||  $search  eq  ""){
      print "$th\n";
#  print Dumper  ("Checking  $th  \n")
  }
  #  increment  the  progress  bar  object  to  tell  it  a  step  has  been  taken.
  #  $progress++;
  }
  }
  #  See  also  use  of  '$progress  +=  $number'  later  in  pod
  sub  sx  {
  no  warnings;
  my  (  @res  )  =  @_;
  my  ($i,  $t,  $_)  =  (undef,"",undef);
  for  (  @res  )  {  tr/a-zA-Z//cd;  tr/a-zA-Z/A-ZA-Z/s;
  ($i,$t)  =  /(.)(.*)/;
  $t  =~  tr/BFPVCGJKQSXZDTLMNRAEHIOUWY/111122222222334556/sd;
  $_  =  substr(($i||'Z').$t.'000',  0,  4  );
  }
  wantarray  ?  @res  :  $res[0];
}
sub  translate  {
  return  unless  -f;
  @check  =  ();
  (my  $rel_name  =  $File::Find::name)  =~  s{./*/*}{}xs;
  my  $first  =  "";
  my  $xname  =  $rel_name;
  $xname  =  pop  [split("/",$rel_name)];
  my  $remove  =  shift  [split("/",$rel_name)];
  $xname  =~  s/([s|S]pringer.|.pdf|The|micro|relations|.json|$remove)/-/gui;
  my  @sy  =  split(/(\.|\(|\)|\_|\  |,|-)/,$xname);
  foreach(@sy){
  push  @check,lc  $_  unless(length($_)<=2);
  }
  @sy  =  App::DrKnow::sx(@check);
  @sy  =  grep{!/Z000/}@sy;
  if  (/\.html$/)  {
  }
  elsif  (/\.pdf$/){
  my  $s  =  join("_",@sy);
  $s  =  "empty"  unless($s);
  my  $name=sprintf("%s\t%s",$s,$rel_name);
  $files->{pdf}->{$s}=$rel_name;#=>{name=>$rel_name,check=>\@check}};
  }elsif(/\.json$/)  {
  my  $s  =  join("_",@sy);
  $s  =  "empty"  unless($s);
  my  $name=sprintf("%s\t%s",$s,$rel_name);
  $files->{json}->{$s}=$rel_name;#={$rel_name=>{name=>$rel_name,check=>\@check}};
  }elsif  (/\.ltx$/)  {
  }elsif  (/^AI*\.pm$/)  {
  }elsif  (/\.txt$/)  {
  my  $s  =  join("_",@sy);
  $s  =  "empty"  unless($s);
  my  $name=sprintf("%s\t%s",$s,$rel_name);
  $files->{txt}->{$s}=$rel_name;#={$rel_name=>{name=>$rel_name,check=>\@check}};
  }else{
  }
}
sub  convertJson  {
my  $self  =  shift;
my  $file  =  shift;
return  unless(-f  $file);
  my  @lines  =  ();
  my  $filename  =  sprintf("%s",$file);

  open(IN,$filename)  or  warn  "Error:  couldn't  open  file  $filename  :  $!\n";
  my  $lines=join("",<IN>);
  close  (IN);
  my  $sense  =  JSON::XS->new->pretty(1)->decode($lines);
 # $self->{graph}->add($file);
  $data->{$filename}={text=>$sense};
  return  $sense;
}
sub  createJsonFile{
  my  $self  =  shift;
  my  $uri  =  shift;
  my  $json  =  shift;
open  (MYFILE,sprintf('>%s.json',$uri));
print  MYFILE  encode_json($json);
close  (MYFILE);
}
sub  decruft  {
  my  $self  =  shift;
  my($file)  =  @_;
  return  unless(-f  $file);
  my($cruftSet)  =  q{%§&|#[^+*(  ]),'";  };
  my  $clean  =  $file;
  $clean=~s/\Q$_//g  for  split("",$cruftSet);
#  system("mv  '$file'  $clean")  unless($file  eq  $clean);
  return  $clean;
}
sub  convertPdf  {
my  $self  =  shift;
my  $file  =  shift;
return  unless(-f  $file);
  my  $dir  =  $self->{tempdir};
  my  $output_dir  =  $dir;
  my  $id  =  md5_hex($file);
  my  $name  =  pop  [split("/",$file)];
  my  $string  =  `$pdftk  @{[quotemeta($file)]}  dump_data  output -`;
  my(  $last_page  )  =  $string  =~  m/NumberOfPages: (\d+)/;
  my  $index  =  File::Spec->catfile(  $dir,"$name.meta");
  open  my  $ih,  '>',  $index  or  warn  "Can't  write  $index  ($!)\n";
  print  $ih  $string;
  close  $ih;
  say  "last  page  is  $last_page";
  `pdftotext  @{[quotemeta($file)]}  '$dir/$name.txt'`;

   next unless($last_page);

  my  $lines  =  `wc  -l  '$dir/$name.txt'`;
  my  $s  =  sprintf  "%d",($lines/$last_page);
  `micro-dict  '$dir/$name.txt'  |  data-freq  >  '$dir/$name-all.freq'`;
  #`split  -l  $s  '$name.txt'  '$name.new'`;
  my  @files  =  split(/\n/,`cat  '$dir/$name.txt'`);
#  my  @files  =  split(/^/,`ls  *  |  egrep  "^$name.*.new.*"`);
  my  $buff  =  "";
  my  $pages  =  {};
  my  $i  =0;
  my  $x=0;
  foreach(@files)  {
  $buff.="\n".$_;
  $i++;
  if($s<=$i  &&  $_=~/[a-z|A-Z|0-9]/){
#  print  $_."\n"  unless();
  my  $next  =  $buff;
  $next  =~s/\n/ /g;
  $next  =~s/"//g;
  if(defined  $opts{deep}  &&  $opts{deep}==1){
  $pages->{$x."_".md5_hex($x)}={text=>$buff,dict=>[split("\n",`bash  micro-dict  "$next"  |  data-freq  --limit  10  |  tr  -d  " "  |  tr  ":"  "="`)]};
  }else{
  $pages->{$x."_".md5_hex($x)}={text=>$buff};
  }
  $i=0;
  $x++;
  $buff="";
  }
  }

  $self->createJsonFile(sprintf("%s/%s",$dir,$name),$pages);
  return  $pages;
}
sub  invoke  {
my  $self  =  shift;
my  $type  =  shift  ||  "pdf";
find(\&translate,  sprintf("/%s",$opts{directory}));
if($opts{verbose}==1){
$search  =  sprintf("%s",join("|",split("\n",`micrownet  $opts{content}`)));
$search  =~  s/\n/\|/g;
$search  =~  s/ /|/g;
$search  =  substr($search,0,length($search)-1);
}else{
  $search  =  $opts{content};
}

foreach(sort{$a  cmp  $b}  keys  %{$files->{$type}}){
  my  $find  =  App::DrKnow::sx(($search));
  my  $show  =  $files->{$type}->{$_};
  if($show  =~  m/($search)/gui  ||
  $files->{$type}->{$_}  =~  m/($search)/gui){
#  $show  =~  s/\n|  /./g;
  my  $x  =  30-length($_);
  my  $eshow  =  pop  [split('/',$show)];
  my  $msg = sprintf("%s=%s%s\n",$_,substr($eshow,0,94));
  emit($msg."\n");
  $found->{$type}->{$show}=$show;
#  p@{$files->{$_}};
#  foreach  my  $f(@{$files->{$_}}){
  #  }
  }else{
  }
};
return  $files->{$type};
}
sub  trim
{
  my  $string  =  shift;
  $string  =  ""  unless  $string;
  $string  =~  s/^\s+//;
  $string  =~  s/\s+$//;
  $string  =~  s/\t//;
  $string  =~  s/^\s//;
  $string  =~  s/^->//;
  $string  =~  s/^=>//;
  return  $string;
}
sub  status  {
  my  $self  =  shift;
  my($url)  =  @_;
  return @_;
}
sub  action  {
  my  $self  =  shift;
  my($url)  =  @_;
  local  $Log::Log4perl::caller_depth  =
  $Log::Log4perl::caller_depth  +  1;
    my  $status  =  App::DrKnow::status();

  _confirm("$status  $url  =>  ",  basename($url))  or  return  1;
  return  0;
}










  my  $geo = {};
  my  $out = "";

  my $action = "";
  my  @x=split("\n",`micrownet  $opts{"categorys"}; `);
  my $more = {};

  p @x;
  p %opts;

  my   $app  =  App::DrKnow->new( );
  print $app->usage();




if(!$app->action("Rerun last $opts{categorys} => ",$opts{categorys})){


p $action;
p $geo;

}else{

print "0";
}



  $app->checkStructures();
  foreach  my  $t(qw/pdf  json/)  {

  $app->invoke($t);

  my  @keyd  =  keys  %{$found->{$t}};
  my  $runner  =  Parallel::Runner->new($#keyd);
  foreach(@keyd){
  $runner->run(  sub  {
  my  $n=pop  [split("/",$_)];
  $n  =~  s/\s//;
  my  $f  =  sprintf('%s/%s.pdf',$app->{tempdir},$n);
 system(sprintf("IFS=\$'\n';  cp  '/$_' '%s/%s'",$app->{tempdir},$n))unless($t!~/json/);
#  system(sprintf("IFS=\$'\n';  pdftotext  -q  -htmlmeta  -raw  '/$_'  '%s/%s.html'  ",$app->{tempdir},$n))unless($t!~/pdf/);
#  system(sprintf("IFS=\$'\n';  pdftotext  -q  '/$_'  '%s/%s.txt'  ",$app->{tempdir},$n))unless($t!~/pdf/);
#  system(sprintf("micro-dict  '%s*txt'",$app->{tempdir},$n))unless($t!~/pdf/);
#  system(sprintf("IFS=\$'\n';  pdftotext  -q  '%s/%s.pdf'  '%s/%s.txt'  ",$app->{tempdir},$n,$app->{tempdir},$n))  unless($t!~/pdf/);
  #  system(sprintf("IFS=\$'\n';  rm  '%s/%s.pdf'  ",$app->{tempdir},$n))unless($t!~/pdf/);

  $f=~  s/.pdf$/.txt/g;

  $geo->{md5_hex($_)} = $app->convertPdf("/$_")  unless($t!~/pdf/);


  #pdftotext  '/$_'  %s/%s.pdf",$app->{tempdir},$n))unless($t!~/pdf/);
  $geo->{md5_hex($_)} = $app->convertJson("/$_")  unless($t!~/json/);


  #emit($data->{$_});
}
 );
  }
  $runner->finish;
  }
 printf("%s\n","@"x190);



my @vals = @{[values %$data]};
my @all = @{[keys %$data]};

  @x=split("\n",`micrownet $opts{categorys}`);#for i in \$(micrownet dna); do for q in \$(micrownet \$i); do micrownet \$q; done done | sort -u
use Search::ContextGraph;
use IO::Dir;
use AI::Categorizer::Document;
p  $app;


  my $cg = Search::ContextGraph->load_from_dir($app->{tempdir});
  my ( $docs, $words ) = $cg->search(\@x);

  ( $docs, $words ) =
             $cg->mixed_search( { docs  => [$cg->doc_list],
                                  terms => \@x}
                              );

  foreach my $w ( sort { $docs->{$b} <=> $docs->{$a} }
    keys %{ $docs } ) {

    if($docs->{$w}>100) {
      $more->{docs}->{$w} = $docs->{$w};
      $action .= sprintf "\nrelevance %.3f doc %s", $docs->{$w},$w;
    }
  }


      # Print out result set of returned documents

foreach my $w ( sort { $words->{$b} <=> $words->{$a} }
   keys %{ $words } ) {

   if($words->{$w}>100){
     $more->{words}->{$w} = $words->{$w};
     $action .= sprintf "\nrelevance %.3f word %s", $words->{$w},$w;

   }
}



if(!$app->action("Compile a book over $opts{categorys} => ",$opts{categorys})){

p $more;
p $action;
p $geo;

}else{

print "0";
}





my $term = new Term::ShellUI(commands =>$app->getCommands(),
      history_file => '~/.active-memory');
      $term->prompt(sub {"active-memory> " });
      $term->run();
1;


#walk($app->{tempdir},$app->{tempdir});

sub walk {
  my($dir, $parent) = @_;
  warn "\nwalk $dir $parent\n";

  my $d = IO::Dir->new($dir);
  foreach my $file ($d->read) {
    next if $file =~ /^\./;

    if (-f $dir ."/". $file && $file =~ /\.json$/) {


              my $d = new AI::Categorizer::Document(name => $dir ."/". $file,

                                              content => { body =>$app->convertJson($dir ."/". $file)->{article} },

                                             );


    } elsif (-d $dir . $file) {
      warn "$file in $dir is DIR\n";
      walk($dir . $file . '/', $dir);
    }
  }
#  warn "\n";
}




__DATA__


my $action = "";

my @vals = @{[values %$data]};
my @all = @{[keys %$data]};

my  @x=split("\n",`micro any all`);#for i in \$(micrownet dna); do for q in \$(micrownet \$i); do micrownet \$q; done done | sort -u
use Search::ContextGraph;
use IO::Dir;
use AI::Categorizer::Document;
p  $app;


  my $cg = Search::ContextGraph->load_from_dir($app->{ramdisk});
  my ( $docs, $words ) = $cg->search(@x);
  my ( $docs, $words ) =
             $cg->mixed_search( { docs  => [$cg->doc_list],
                                  terms => \@x}
                              );

  foreach my $w ( sort { $docs->{$b} <=> $docs->{$a} }
    keys %{ $docs } ) {

    if($docs->{$w}>=100) {
      $action .= sprintf "doc\t%s\thad\trelevance\t%s",$w, $docs->{$w}, "\n";
    }
  }

p $action;
#p $docs;
#p $words;
      # Print out result set of returned documents
my $more = {};
foreach my $w ( sort { $words->{$b} <=> $words->{$a} }
   keys %{ $words } ) {

   if($words->{$w}>=100){
     $more->{$w} = $words->{$w};
     $action .= sprintf "word\t%s\thad\trelevance\t%s",$w, $words->{$w}, "\n";
   }
}



p $more;

#Swalk($app->{tempdir},$app->{tempdir});

sub walk {
  my($dir, $parent) = @_;
  warn "\nwalk $dir $parent\n";

  my $d = IO::Dir->new($dir);
  foreach my $file ($d->read) {
    next if $file =~ /^\./;

    if (-f $dir ."/". $file && $file =~ /\.json$/) {


              my $d = new AI::Categorizer::Document(name => $dir ."/". $file,

                                              content => { body =>$app->convertJson($dir ."/". $file)->{article} },

                                             );


    } elsif (-d $dir . $file) {
      warn "$file in $dir is DIR\n";
      walk($dir . $file . '/', $dir);
    }
  }
#  warn "\n";
}



__END__

use Search::ContextGraph;
use IO::Dir;
use AI::Categorizer::Document;
p  $app;


  my $cg = Search::ContextGraph->load_from_dir($app->{tempdir});
  my $more = {};
  my ( $docs, $words ) = $cg->search(\@x);

    p $docs;
    p $words;



  ( $docs, $words ) =
             $cg->mixed_search( { docs  => [$cg->doc_list],
                                  terms => \@x}
                              );


    p $docs;
    p $words;


  foreach my $w ( sort { $docs->{$b} <=> $docs->{$a} }
    keys %{ $docs } ) {

    if($docs->{$w}>=100) {
      printf "doc\t%s\thad\trelevance\t%s",$w, $docs->{$w}, "\n";
    }
  }


      # Print out result set of returned documents

foreach my $w ( sort { $words->{$b} <=> $words->{$a} }
   keys %{ $words } ) {

   if($words->{$w}>=100){

      printf "word\t%s\thad\trelevance\t%s",$w, $words->{$w}, "\n";
   }
}



p $more;
__DATA__


my $action = "";

my @vals = @{[values %$data]};
my @all = @{[keys %$data]};
my @qq = [split("\n",`for i in \$(micrownet $search); do for q in \$(micrownet \$i); do micrownet \$q; done done | sort -u`)];


emit(@qq);

use Search::ContextGraph;
use IO::Dir;
use AI::Categorizer::Document;
p  $app;


  my $more = {};
  my $cg = Search::ContextGraph->load_from_dir($app->{tempdir});
  my ( $docs, $words ) = $cg->search(@qq);
  my ( $docs, $words ) =
             $cg->mixed_search( { docs  => [$cg->doc_list],
                                  terms => \@qq}
                              );

  foreach my $w ( sort { $docs->{$b} <=> $docs->{$a} }
    keys % $docs  ) {

    if($docs->{$w}>=100) {
      $more->{docs}->{$w} = $docs->{$w};
      printf "doc\t%s\thad\trelevance\t%s",$w, $docs->{$w}, "\n";
    }
  }

      # Print out result set of returned documents
my $more = {};
foreach my $w ( sort { $words->{$b} <=> $words->{$a} }
   keys %$words ) {

   if($words->{$w}>=100){
     $more->{words}->{$w} = $words->{$w};
     printf "word\t%s\thad\trelevance\t%s",$w, $words->{$w}, "\n";
   }
}


p $action;
p $docs;
p $words;
p $more;



#Swalk($app->{tempdir},$app->{tempdir});

sub walk {
  my($dir, $parent) = @_;
  warn "\nwalk $dir $parent\n";

  my $d = IO::Dir->new($dir);
  foreach my $file ($d->read) {
    next if $file =~ /^\./;

    if (-f $dir ."/". $file && $file =~ /\.json$/) {


              my $d = new AI::Categorizer::Document(name => $dir ."/". $file,

                                              content => { body =>$app->convertJson($dir ."/". $file)->{article} },

                                             );


    } elsif (-d $dir . $file) {
      warn "$file in $dir is DIR\n";
      walk($dir . $file . '/', $dir);
    }
  }
#  warn "\n";
}


sub pr{
#p @_;
  }
sub ok{

pr(@_);

  }
sub is{

pr(@_);
  }
my @term=();
 my $path = "Search::ContextGraph::Test::Stored";
my %docs=();
for my $XS ( 0..1 ) {

  last if $XS; # XS IS BROKEN IN THIS VERSION!
  my @x = split("|",$search);
  my $more = {};

  my $cg = Search::ContextGraph->load_from_dir($app->{tempdir});

  my ( $docs, $words ) = $cg->search(\@x);
  my ( $docs, $words ) =
             $cg->mixed_search( { docs  => [$cg->doc_list],
                                  terms => \@x}
                              );

  foreach my $w ( sort { $docs->{$b} <=> $docs->{$a} }
    keys %{ $docs } ) {

    if($docs->{$w}>100) {
      printf( "doc\t%s\thad\trelevance\t%s\n",$w, $docs->{$w});
    }
  }

foreach my $w ( sort { $words->{$b} <=> $words->{$a} }
   keys %{ $words } ) {

   if($words->{$w}>100){
      push @term,$w;
      printf("word\t%s\thad\trelevance\t%s\n",$w, $words->{$w});
   }
}
}


__DATA__



  my ($docs, $words ) = $cg->search($x[0]);


  ( $docs, $words ) = $cg->search(\@x);
ok([$docs, $words]);
  ( $docs, $words ) = $cg->search(\@term);
ok([$docs, $words]);
  ( $docs, $words ) = $cg->find_similar($term[0]);
ok([$docs, $words]);


  # Try storing the sucker
  if ( !$XS ) {
    my $path = $app->{tempdir};
    eval { $cg->store( $path ) };
    ok( !length $@, "able to store object to file" );

    my $x = Search::ContextGraph->load_from_dir( $path );
    ok( UNIVERSAL::isa( $x, 'Search::ContextGraph'), "reload object from stored file" );

    #cleanup
    eval { unlink $path; };
    ok( !length $@, "remove stored file" );


    ($docs, $words ) = $cg->find_similar('First Document');
    is(sprintf("%2.2f", $docs->{"First Document"}), 122.34, 'reloaded search object works fine');
  }

  my $y = Search::ContextGraph->new( debug => 1, xs => $XS );
  $path = sprintf("%s/sample.tdm",$app->{tempdir});
  $y->load_from_tdm( $path );
  ok( !length $@, "able to load TDM file $@" );
  is( $y->doc_count(), 177, "correct document count" );
  is( $y->term_count(), 2036, "correct term count" );


  ($docs, $words) = $y->mixed_search( { terms => [ 111, 109, 23 ], docs => [33,21,12] });
  is( scalar keys %$words,141, "Got right number of results");
  is(sprintf("%2.2f", $docs->{163}), 1.09, "mixed search got right doc value");
  is(sprintf("%2.2f", $words->{248}), 0.52, "mixed search got right term value");





}
__DATA__


my $action = "";

my @vals = @{[values %$data]};
my @all = @{[keys %$data]};

my  @x=split("\n",`micro any all`);#for i in \$(micrownet dna); do for q in \$(micrownet \$i); do micrownet \$q; done done | sort -u
use Search::ContextGraph;
use IO::Dir;
use AI::Categorizer::Document;
p  $app;


  my $cg = Search::ContextGraph->load_from_dir($app->{ramdisk});
  my ( $docs, $words ) = $cg->search(@x);
  my ( $docs, $words ) =
             $cg->mixed_search( { docs  => [$cg->doc_list],
                                  terms => \@x}
                              );

  foreach my $w ( sort { $docs->{$b} <=> $docs->{$a} }
    keys %{ $docs } ) {

    if($docs->{$w}>=100) {
      $action .= sprintf "doc\t%s\thad\trelevance\t%s",$w, $docs->{$w}, "\n";
    }
  }

p $action;
#p $docs;
#p $words;
      # Print out result set of returned documents
my $more = {};
foreach my $w ( sort { $words->{$b} <=> $words->{$a} }
   keys %{ $words } ) {

   if($words->{$w}>=100){
     $more->{$w} = $words->{$w};
     $action .= sprintf "word\t%s\thad\trelevance\t%s",$w, $words->{$w}, "\n";
   }
}



p $more;

#Swalk($app->{tempdir},$app->{tempdir});

sub walk {
  my($dir, $parent) = @_;
  warn "\nwalk $dir $parent\n";

  my $d = IO::Dir->new($dir);
  foreach my $file ($d->read) {
    next if $file =~ /^\./;

    if (-f $dir ."/". $file && $file =~ /\.json$/) {


              my $d = new AI::Categorizer::Document(name => $dir ."/". $file,

                                              content => { body =>$app->convertJson($dir ."/". $file)->{article} },

                                             );


    } elsif (-d $dir . $file) {
      warn "$file in $dir is DIR\n";
      walk($dir . $file . '/', $dir);
    }
  }
#  warn "\n";
}

__DATA__
#  my $cg = Search::ContextGraph->load_from_dir("/mnt/myramdisk/");


   my ( $docs, $words ) = $cg->search(@x);



p $docs;
p $words;

 ( $docs, $words ) =
           $cg->mixed_search( { docs  => [$cg->doc_list],
                                terms => \@x}
                            );


p $docs;
p $words;
      # Print out result set of returned documents
         foreach my $w ( sort { $words->{$b} <=> $words->{$a} }
             keys %{ $words } ) {
             print "word $w had relevance ", $words->{$w}, "\n" unless($words->{$w}<=10);
         }


         # Print out result set of returned documents
         foreach my $k ( sort { $docs->{$b} <=> $docs->{$a} }
             keys %{ $docs } ) {
             print "Document $k had relevance ", $docs->{$k}, "\n" unless($docs->{$k}<=101);
         }

#p $cg;
use AI::MicroStructure::any;
use GraphViz::Small;
#use GraphViz::No;
use Time::HiRes qw( usleep );

my  $app = App::DrKnow->new("/mnt/myramdisk/");
my  $micro = AI::MicroStructure->new();
my  @t = $micro->structures;


my $set = AI::MicroStructure::ObjectSet->new();

my $directory = '/home/santex/data-hub';

my  $graph = GraphViz::Small->new(directed => 0, layout => 'twopi');

sub walker {
  my($parent,@t) = @_;
  my @in;




  $graph->add_node("micro");


  foreach my $file (@t) {

      next if($file =~/space.*.station/);

      $graph->add_node($file , label => $file);




      foreach my $e (sort $micro->name("$file",0)){

        if(! grep{/^$e/}@in){

        $graph->add_node($file , label => $e);
        $graph->add_edge($file => $e);
        push @in,$e;


        print $file."\t$e\n";
        }
      }

  }




  }



my $term = new Term::ShellUI(commands =>$app->getCommands(),
      history_file => '~/.active-memory');
      $term->prompt(sub {"active-memory> " });
      $term->run();
1;
#
#
#tar =>,
__DATA__
foreach my $x ( "s".."z"){

  $graph = GraphViz::Small->new(directed => 0, layout => 'twopi');
  walker($x,grep{/^$x/}@t);
  $graph->as_png(sprintf("%s_directories.png",$x));
  usleep(1000);

}









































