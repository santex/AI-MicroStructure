#!/usr/bin/perl -w


BEGIN {
  unshift @INC, ".";




use Pod::Usage;
use AI::MicroStructure;
use vars qw( $VERSION );
use vars qw( @ARCHIVES );

@ARCHIVES = qw(

);

use strict;
use warnings;
use File::Basename;
use File::Copy;
use File::Find;
use File::Path;
use IO::File;
use IO::Dir;
use AI::Categorizer::Document;
use Digest::MD5 qw(md5_hex);
use Data::Dumper;
use Data::Printer;
use Digest::MD5 qw(md5_hex);
#use AI::MicroStructure::ObjectSet;
use Env qw(PWD);
use Getopt::Long;
use Text::Autoformat;
use Term::ShellUI;
use  Term::Emit  qw/:all/,  {-bullets  =>  ["  *  ",  "  +  ",  "  -  ",  "  "],
    -color  =>  1,
    -closestat  =>  "TOTAL",
    -fh  =>  *STDOUT,
    -width=>60};
our $curSysDate = `date +"%F"`;
    $curSysDate=~ s/\n//g;
our $cache={};

our $files={};
our $out = "";
our $meta = AI::MicroStructure->new();
our @t = $meta->structures;


my $TOP = "/home/santex/data-hub";
my $TOP_URL = "http://www.stonehenge.com/merlyn/WebTechniques";
my $OUT = "/home/santex/";

our $ident = sprintf "%s%s",$0,join(" ",@ARGV);

my @paths = split /:/, $ENV{PATH};


our %opts = (cache_file => sprintf("%s/%s_micro.cache","/tmp",$curSysDate),
             dir        =>  $ENV{HOME},#:$meta->{state}->{cfg}->{"default"},
             mime        => ".*",
             filter        => "micro-relations-",
             match        => "",
             max_cache_age => 5,
             silent=>0,
             full=>0,
             help=>0,
             short=>0,
             level=>5,
             scope=>3);

GetOptions (\%opts, "cache_file=s","match=s", "max_cache_age=i" ,"full=i" ,"short=i" ,"help=i", "filter=s", "mime=s","dir=s","silent=i","level=i","scope=i");

my  $descriptions = {action=>{},type=>{},location=>{}};
    $descriptions->{action} = {
                    'new'     =>"creates something !",
                    'list'    =>"lists something",
                     'search'    =>"search something",
                     'view'  =>"displays a search",
                     'export'    =>"creates a book",
};
    $descriptions->{type} = {
    'new'     =>"things you dont have yet",
    'my'      =>"things you have already",
    'related' =>"things which are related to you",
    'expanding' =>"expanding knowledge",
    #'fit'    =>"usefull things",
    };
    $descriptions->{location} = {
      'category'     =>"on ymy  computer",
      'content'     =>"on a distant computer",
     };

my  $cmd={"h" =>                { alias => "help", exclude_from_completion => 0 },
                "?" =>          { alias => "help", exclude_from_completion =>1 },
    "quit" =>           { alias => "exit", exclude_from_completion =>0 },
                "help" => {
                        desc =>sub{ print usage();},
                        args => sub { shift->help_args(undef, @_); },
                        method => sub { shift->help_call(undef, @_); }
                },
                "history" => { desc => "Prints the command history",
                        doc => "Specify a number to list the last N lines of history\n" .
                                "Pass -c to clear the command history, " .
                                "-d NUM to delete a single item\n",
                        args => "[-c] [-d] [number]",
                        exclude_from_completion =>1,
                        method => sub { shift->history_call(@_) },
                },
                "exit" => {
                        desc => "Exits the program.",
                        maxargs => 0,
                        exclude_from_completion =>1,
                        method => sub { shift->exit_requested(1); },
                },
                "quit" => {
                        desc => "Quit using Fileman",
                        maxargs => 0,
                        method => sub { shift->exit_requested(1); }, exclude_from_completion =>0,
                },
                # Term::ShellUI normally displays "asdf: unknown command".
                # This shows how to use the default command.  If the user
                # type an unknown command, ShellUI calls '' if it exists.
                '' => {
                        proc => "No command here by that name!\n",
                        desc => "No help for unknown commands.",
                        doc => "Well, here's a little help: don't type them.\n",
                },
        };
my  $location = {
  "category" => {
        args => "(path)",
        desc => "use list new",
        proc => sub {
                                                my $self = shift;
                                                my $parms = shift;
                                                print get_cname(@_) .
                                                        ": " . join(" ",@_), "\n";
                                        },
                },
"content" => {
                        args => sub {   },
        desc => $descriptions->{location}->{content},
        proc => sub{  App::DrKnow::invoke(); }}
};

  my  %name = (action=>[qw/list use new/],#search get set   change plot cloudy
                          type=>[qw/new my related/],# popular growing fit term
                          location=>[qw/category content/]);





  $opts{match} = $opts{mime} unless(length($opts{match}));

  if($opts{full}){
    $opts{scope} = $opts{scope}+1;
  };

  our $found = 0;

  package MyContent;
  use Data::Dumper;
  use Storable qw(lock_store lock_retrieve);
  use File::Path;
  use File::Temp qw(tempdir);

  sub new {

    my($package,  %options)  =  @_;
    my  $self  =  {
    tempdir=>tempdir(),
    %options,
    };
    bless  $self,  $package;


    if(defined  $self->{ramdisk})  {
    my  $rc  =  $self->ramdisk_mount(  %{  $self->{ramdisk}  }  );
    if(!$rc)  {
    warn  "Mounting  ramdisk  failed";
    }
    $self->{tmpdir}  =  $self->{ramdisk}->{tmpdir};
    }  else  {
    $self->{tmpdir}  =  tempdir($self->{tmpdir}  ?
    (DIR  =>  $self->{tmpdir})  :  ());
    }
    $self->{tardir}  =  File::Spec->catfile($self->{tmpdir},  "tar");
    mkpath  [$self->{tardir}],  0,  0755  or
    warn  "Cannot  mkpath  $self->{tardir}  ($!)";


    $self->{objdir}  =  File::Spec->catfile($self->{tmpdir},  "objdir");
    mkpath  [$self->{objdir}],  0,  0755  or
    warn  "Cannot  mkpath  $self->{objdir}  ($!)";



    return $self;
  }

  sub load {

    eval {
        local $^W = 0;  # because otherwhise doesn't pass errors

        $cache = lock_retrieve($opts{cache_file});

        if($@){
          lock_strore($cache,$opts{cache_file});
        }
        $cache = {} unless $cache;

        warn "New cache!\n" unless defined $cache;

        if($cache->{$ident} && (time - $cache->{$ident}->{time}) /3600){

        }else{
           $cache->{$ident}->{time}=time;
        }


    };


      print Dumper [keys %{$cache}];

    }

  sub DESTROY {

  my $self = shift;

  $self->{cache} = $cache;

  $cache->{$ident}->{time}=time;
  $cache->{$ident}->{out}=$out;
  $cache->{$ident}->{arg}=join(" ",@ARGV);

  lock_store($self->{cache},$opts{cache_file});


  }
  sub start {
    my $self = shift;
  }

  sub sxe {

  my ( @res ) = @_;
  my ($i, $t, $_);

  for ( @res ) { tr/a-zA-Z//cd; tr/a-zA-Z/A-ZA-Z/s;
      ($i,$t) = /(.)(.*)/;
      $i = "" unless($i);
      $t = "" unless($t);

     $t =~ tr/BFPVCGJKQSXZDTLMNRAEHIOUWY/111122222222334556/sd;
     $_ = substr(($i||'Z').$t.'000', 0, 4);

  }
  wantarray ? @res : $res[0];
}

sub  trim
{
  my $self = shift;
  my  $string  =  shift;
  $string  =  ""  unless  $string;
  $string  =~  s/^\s+//;
  $string  =~  s/'|"//g;
  $string  =~  s/\s+$//;
  $string  =~  s/\t//;
  $string  =~  s/^\s//;
  $string  =~  s/^->//;
  $string  =~  s/^=>//;
  return  $string;
}


sub  getCommands  {
my  @c  =  keys  $descriptions->{action};
foreach  my  $ele  (@c){
  my  $s  ={};
  $cmd->{$ele}->{cmds}  =  $s;
  foreach  (keys  %{$descriptions->{location}}){
  $s->{$_}->{cmds}  =  {};
  }
}
  return  $cmd;
}




sub translate {


  return unless -f;
  (my $rel_name = $File::Find::name) =~  qr/\.[^.]*/;



  if (/\.$opts{mime}$/) {

  if($rel_name =~ /$opts{match}/i)  {

   # print $rel_name."\n";
  my @nam = split("/",$rel_name);
  my $xname =  $nam[$#nam];
  my $linkname = $opts{full} == 1 ? $rel_name : $xname;
  $xname =~ s/[s|S]pringer.//gui;
  my @words = split("(_| - | |,|-)",$xname);

  my @sy = MyContent::sxe(@words);


  $linkname =~ s/$opts{filter}//g;
  @sy = grep{!/(00|A530|A500|0100)/}@sy;
  @sy = @sy[0..$opts{level}] unless($#sy<$opts{level});

    my $name="";

    if($opts{short}==0){

      $name = sprintf("%40s%s%s%4s%s",join("_",@sy)," ","|","\t"x1,$linkname);
    }else{
      $name = sprintf("%s",$linkname);
    }

  #  if($found % 250==1) {
   #   printf "\n%s\t",$found;
    #}
    #if($found % 10==1) {
     # printf ".";
   # }


    $found++;
    $files->{$opts{mime}}->{$name} = $linkname;
    if($sy[0]){
    push @{$cache->{$ident}->{$sy[0]}},$linkname;
#    @{$cache->{$ident}->{$sy[0]}}=sort @{$cache->{$ident}->{$sy[0]}};
    }
 #   @{$cache->{$_}->{$words[0]}} = sort @{$cache->{$_}->{$words[0]}} for @sy;
  }
}
}
}


find(\&MyContent::translate, "$opts{dir}");


my @out = ();
my $app = new MyContent(@ARGV);
my $i = 1;
my @ll  = keys %{$files->{$opts{mime}}};
foreach(sort{$a cmp $b} @ll){
  next unless $_;
  my $row = $_;
     $row =~ s/ //g;

 $app->{last} = "" unless( $app->{last});


if(substr($app->{last},0,$opts{scope}*4) ne substr($row,0,$opts{scope}*4)){

  @out = sort @out;
  $out .= sprintf("\n(%d)\n%s\n",$#out+1,"."x (length($out[0])+5)) unless(!$out[0]);
  $out .= join("",@out);

#  my $lenghth = length($_);
#    sprintf "%s", eval{
#    '$out .= sprintf( "%s%s\n",\$i,"."x'.$lenghth.') if(\$out =~ /./);'
#  };
  @out = ();
  $i=1;
}else{
  $i++;
}

push @out,autoformat { all => 1, ignore => sub { tr/\n/\n/ < 3
               } }, $app->trim($_);
$app->{last} = $row;



};


sub postamble {

  my $cooky = `micro`;

  my $postamble = '<h2>'.$cooky.'</h2>';
  $postamble .= <<'END';

  <script>


function ucfirst(incomming){ return incomming.charAt(0).toUpperCase() + incomming.substring(1);}

function goTo(thisid,type,additional){
 var ident = "";
 switch (type) {
 case -1:
 ident = additional+"#"+$(thisid).html();
 break;
 case 0:
 ident = "Category:"+$(thisid).html();
 break;
 case 1:
 ident = "List_of_"+$(thisid).html();
 break;
 case 2:
 ident = ""+$(thisid).html();
 break;
 }
 if(!ident.match("http://")){
 ident = "http://en.wikipedia.org/wiki/"+ucfirst(ident.replace(/ /g,"_"));
 }
 window.open(
 ident.toString(),
 '_blank'
);
}


  </script>
END
  return ($postamble);
}


sub broker {


  my $target = "/home/santex/data-hub/data/data-hub.html";


my @set = split(/^/, $out);

open FILE, ">$target" or warn "Can't open $target ($!)";
print FILE postamble;
print FILE "<pre>";
print FILE "<div style='color:green;zoom:80%;'>";

foreach (@set){
  my @l = split("[\\|]",$_);
  if($l[0]=~ /[.|\(]/ || $app->trim($l[0]) eq ""){
  print FILE  sprintf("%s",$_);
  }else{
  $l[2] = $app->trim($l[1]);
  $l[2] =~ s/.json//g;
  print FILE  sprintf("<li onClick=goTo(this,'%s','%s'); >%s</li>",$app->trim($l[0]),$l[2],$app->trim($l[1]));
  }
}
print FILE "</div>";
print FILE "</pre>";
close FILE;



print STDOUT $out;
#äp $out;



#my $term = new Term::ShellUI(commands =>MyContent::getCommands(),
#      history_file => '~/.active-memory');

#      $term->prompt(sub {"active-memory> " });
#      $term->run();
1;


#walk($app->{tempdir},$app->{tempdir});



}

broker(@ARGV);


sub usage {

print <<EOF;

\033[0;34m
             i!~!!))!!!!!!!!!!!!!!!!!!!!!!!!
          i!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
       i!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    '!h!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  '!!`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i
   /!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
' ':)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ~:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
..!!!!!\!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 `!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ~ ~!!!)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!~
~~'~{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:'~
{-{)!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:!
`!!!!{!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!':!!!
' {!!!{>)`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)!~..
:!{!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -!!:
    ~:!4~/!!!!!!!!!!!!!!!!!!!~!!!!!!!!!!!!!!!!!!!!!!!!!!
     :~!!~)(!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ``~!!).~!!!!!!!!!!!!!{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:
            ~  '!\!!!!!!!!!!(!!!!!!!!!!!!!!!!!!!!!!4!!!~:
           '      '--`!!!!!!!!/:\!!{!!((!~.~!!`?~-      :
              ``-.    `~!{!`)(>~/ \~                   :
   .                \  : `{{`. {-   .-~`              /
    .          !:       .\\?.{\   :`      .          :!
    \ :         `      -~!{:!!!\ ~     :!`         .>!
    '  ~          '    '{!!!{!!!t                 ! !!
     '!  !.            {!!!!!!!!!              .~ {~!
      ~!!..`~:.       {!!!!!!!!!!:          .{~ :LS{
       `!!!!!!h:!?!!!!!!!!!!!!!(!!!!::..-~~` {!!!!.
         4!!!!!!!!!!!!!!!!!!!!!~!{!~!!!!!!!!!!!!'
          `!!!!!!!!!!!!!!!!!!!!(~!!!!!!!!!!!!!~
            `!!!!!!!!!!!{\``!!``(!!!!!!!!!~~  .
             `!!!!!!!!!!!!!!!!!!!!!!!!(!:
               .!!!!!!!!!!!!!!!!!!!!!\~
               .`!!!!!!!/`.;;~;;`~!! '
                 -~!!!!!!!!!!!!!(!!/ .
                    `!!!!!!!!!!!!!!'
                      `\!!!!!!!!!~

\033[0m
EOF
}



if(0)
{
my $term = new Term::ShellUI(commands =>$app->getCommands(),
      history_file => '~/.active-memory');
      #$term->addhistory(@ARCHIVES);
      $term->prompt(sub {"active-memory> " });
      $term->run();


}



__DATA__

sub GetRecord {
  printtitle("GetRecord");

  my $id = $TERM->readline("Enter the identifier to request>",$DEFAULTID) || $DEFAULTID;
  $TERM->addhistory(@PREFIXES);
  my $mdp = $TERM->readline("Enter the mimetype to use>",'*') || '*';

    printheader();

}

sub Identify {
  printtitle("Identify");

}

sub ListIdentifiers {
  printtitle("ListIdentifiers");

  my $resumptionToken = $TERM->readline("Enter an optional resumptionToken>");
  my ($from, $until, $set, $mdp);
  if( !$resumptionToken ) {
    $from = $TERM->readline("Enter an optional from period (yyyy-mm-dd)>");
    $until = $TERM->readline("Enter an optional until period (yyyy-mm-dd)>");
    $TERM->addhistory(@SETS);
    $set = $TERM->readline("Enter an optional set ([A-Z0-9_]+)>");
    $TERM->addhistory(@PREFIXES);
    $mdp = $TERM->readline("Enter the mimetype to use>",'*') || '*';
  }

  my $c = 0;
  my $cb = $opts{silent} ?
    sub { print STDERR $c++, "\r"; } :
    sub {
      my $rec = shift;
      $c++;
      print "identifier => ", $rec->identifier,
        (defined($rec->datestamp) ? " / " . $rec->datestamp : ''),
        ($rec->status ? " (".$rec->status.") " : ''), "\n";
    };

  #printheader($r);
  print "\nRead a total of $c records\n";


}

sub ListMetadataFormats {
  printtitle("ListMetadataFormats");

  my $id = $TERM->readline("Enter an optional identifier>");

}

sub ListRecords {
  printtitle("ListRecords");

  my $resumptionToken = $TERM->readline("Enter an optional resumptionToken>");
  my ($from, $until, $set, $mdp);
  if( !$resumptionToken ) {
    $from = $TERM->readline("Enter an optional from period (yyyy-mm-dd)>");
    $until = $TERM->readline("Enter an optional until period (yyyy-mm-dd)>");
    $TERM->addhistory(@SETS);
    $set = $TERM->readline("Enter an optional set ([A-Z0-9_]+)>");
    $TERM->addhistory(@PREFIXES);
    $mdp = $TERM->readline("Enter the mimetype to use>",'*') || '*';
  }

  my $c = 0;


  print "\nRead a total of $c records\n";

}

sub ListSets {
  printtitle("ListSets");

  sub cb {
    my $rec = shift;
    push @SETS, $rec->setSpec;
    print "setSpec => ", $rec->setSpec, "\n",
      "setName => ", ($rec->setName||'(null)'), "\n";
  };


}

sub input {
  my $q = shift;
  print $q;
  my $r = <>;
  return unless defined($r);
  chomp($r);
  return $r;
}

sub printtitle {
  my $t = shift;
  print "\n$t\n";
  for( my $i = 0; $i < length($t); $i++ ) {
    print "-";
  }
  print "\n";
}

sub printheader {
  my $r = shift;
  print "verb => ", $r, "\n",
}

sub checkargs {
  my %args = @_;
  foreach my $key (keys %args) {
    delete $args{$key} if( !defined($args{$key}) || $args{$key} eq '' );
  }
  %args;
}

sub iserror {
  my $r = shift;
  if( $r->is_success ) {
    return undef;
  } else {

    return 1;
  }
}

__DATA__
&mainloop();

sub mainloop {
  while(1) {
    print "\nMenu\n----\n\n",
      "1. GetRecord\n2. Identify\n3. ListIdentifiers\n4. ListMetadataFormats\n5. ListRecords\n6. ListSets\nq. Quit\n\n>";
    my $cmd;
    MyContent::ReadMode(4);
    $cmd = ReadKey();
    MyContent::ReadMode(0);
    last unless defined($cmd);
    print $cmd . "\n";
    if( $cmd eq 'q' ) {
      last;
    } elsif($cmd eq '1') {
      eval { GetRecord() };
    } elsif($cmd eq '2') {
      eval { Identify() };
    } elsif($cmd eq '3') {
      eval { ListIdentifiers() };
    } elsif($cmd eq '4') {
      eval { ListMetadataFormats() };
    } elsif($cmd eq '5') {
      eval { ListRecords() };
    } elsif($cmd eq '6') {
      eval { ListSets() };
    }
    if( $@ ) {
      warn "Internal error occurred: $@\n";
    }
  }
}





